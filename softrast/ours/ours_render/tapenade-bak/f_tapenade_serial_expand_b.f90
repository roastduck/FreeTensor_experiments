!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.16 (develop) - 14 Jul 2023 15:27
!
MODULE TAPENADE_RENDER_DIFF
  IMPLICIT NONE

CONTAINS
!  Differentiation of face_inv in reverse (adjoint) mode:
!   gradient     of useful results: faces_t inv_t
!   with respect to varying inputs: faces_t inv_t
! Function and Subroutine Declarations
  SUBROUTINE FACE_INV_B(inv_t, inv_tb, faces_t, faces_tb, fn)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: faces_t(3*3*5856*1)
    REAL*8 :: faces_tb(3*3*5856*1)
    INTEGER, INTENT(IN) :: fn
    REAL*8 :: inv_t(3*3)
    REAL*8 :: inv_tb(3*3)
    REAL*8 :: det
    REAL*8 :: detb
    INTEGER :: p
    INTEGER :: d
    INTRINSIC MAX
    INTRINSIC MIN
    REAL*8 :: tempb
    REAL*8 :: tempb0
    REAL*8 :: tempb1
    INTEGER*4 :: branch
    d = (fn-1)*(3*3) + 1
    det = faces_t(d+0)*(faces_t(d+4)-faces_t(d+7)) + faces_t(d+3)*(&
&     faces_t(d+7)-faces_t(d+1)) + faces_t(d+6)*(faces_t(d+1)-faces_t(d+&
&     4))
    IF (det .GT. 0) THEN
      IF (det .LT. 1e-10) THEN
        det = 1e-10
        CALL PUSHCONTROL2B(1)
      ELSE
        CALL PUSHCONTROL2B(0)
        det = det
      END IF
    ELSE IF (det .GT. -1e-10) THEN
      det = -1e-10
      CALL PUSHCONTROL2B(3)
    ELSE
      CALL PUSHCONTROL2B(2)
      det = det
    END IF
    tempb1 = inv_tb(9)/det
    inv_tb(9) = 0.0_8
    faces_tb(d+0) = faces_tb(d+0) + faces_t(d+4)*tempb1
    faces_tb(d+4) = faces_tb(d+4) + faces_t(d+0)*tempb1
    faces_tb(d+3) = faces_tb(d+3) - faces_t(d+1)*tempb1
    faces_tb(d+1) = faces_tb(d+1) - faces_t(d+3)*tempb1
    detb = -((faces_t(d+0)*faces_t(d+4)-faces_t(d+3)*faces_t(d+1))*&
&     tempb1/det)
    tempb1 = inv_tb(8)/det
    inv_tb(8) = 0.0_8
    faces_tb(d+3) = faces_tb(d+3) + tempb1
    faces_tb(d+0) = faces_tb(d+0) - tempb1
    detb = detb - (faces_t(d+3)-faces_t(d+0))*tempb1/det
    tempb1 = inv_tb(7)/det
    inv_tb(7) = 0.0_8
    faces_tb(d+1) = faces_tb(d+1) + tempb1
    faces_tb(d+4) = faces_tb(d+4) - tempb1
    detb = detb - (faces_t(d+1)-faces_t(d+4))*tempb1/det
    tempb1 = inv_tb(6)/det
    inv_tb(6) = 0.0_8
    faces_tb(d+6) = faces_tb(d+6) + faces_t(d+1)*tempb1
    faces_tb(d+1) = faces_tb(d+1) + faces_t(d+6)*tempb1
    faces_tb(d+0) = faces_tb(d+0) - faces_t(d+7)*tempb1
    faces_tb(d+7) = faces_tb(d+7) - faces_t(d+0)*tempb1
    detb = detb - (faces_t(d+6)*faces_t(d+1)-faces_t(d+0)*faces_t(d+7))*&
&     tempb1/det
    tempb1 = inv_tb(5)/det
    inv_tb(5) = 0.0_8
    faces_tb(d+0) = faces_tb(d+0) + tempb1
    faces_tb(d+6) = faces_tb(d+6) - tempb1
    detb = detb - (faces_t(d+0)-faces_t(d+6))*tempb1/det
    tempb1 = inv_tb(4)/det
    inv_tb(4) = 0.0_8
    faces_tb(d+7) = faces_tb(d+7) + tempb1
    faces_tb(d+1) = faces_tb(d+1) - tempb1
    detb = detb - (faces_t(d+7)-faces_t(d+1))*tempb1/det
    tempb1 = inv_tb(3)/det
    inv_tb(3) = 0.0_8
    faces_tb(d+3) = faces_tb(d+3) + faces_t(d+7)*tempb1
    faces_tb(d+7) = faces_tb(d+7) + faces_t(d+3)*tempb1
    faces_tb(d+6) = faces_tb(d+6) - faces_t(d+4)*tempb1
    faces_tb(d+4) = faces_tb(d+4) - faces_t(d+6)*tempb1
    detb = detb - (faces_t(d+3)*faces_t(d+7)-faces_t(d+6)*faces_t(d+4))*&
&     tempb1/det
    tempb1 = inv_tb(2)/det
    inv_tb(2) = 0.0_8
    faces_tb(d+6) = faces_tb(d+6) + tempb1
    faces_tb(d+3) = faces_tb(d+3) - tempb1
    detb = detb - (faces_t(d+6)-faces_t(d+3))*tempb1/det
    tempb1 = inv_tb(1)/det
    inv_tb(1) = 0.0_8
    faces_tb(d+4) = faces_tb(d+4) + tempb1
    faces_tb(d+7) = faces_tb(d+7) - tempb1
    detb = detb - (faces_t(d+4)-faces_t(d+7))*tempb1/det
    CALL POPCONTROL2B(branch)
    IF (branch .LT. 2) THEN
      IF (branch .NE. 0) detb = 0.0_8
    ELSE IF (branch .NE. 2) THEN
      detb = 0.0_8
    END IF
    faces_tb(d+0) = faces_tb(d+0) + (faces_t(d+4)-faces_t(d+7))*detb
    tempb = faces_t(d+0)*detb
    faces_tb(d+3) = faces_tb(d+3) + (faces_t(d+7)-faces_t(d+1))*detb
    tempb0 = faces_t(d+3)*detb
    faces_tb(d+6) = faces_tb(d+6) + (faces_t(d+1)-faces_t(d+4))*detb
    tempb1 = faces_t(d+6)*detb
    faces_tb(d+1) = faces_tb(d+1) + tempb1 - tempb0
    faces_tb(d+4) = faces_tb(d+4) + tempb - tempb1
    faces_tb(d+7) = faces_tb(d+7) + tempb0 - tempb
  END SUBROUTINE FACE_INV_B

! Function and Subroutine Declarations
  SUBROUTINE FACE_INV(inv_t, faces_t, fn)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: faces_t(3*3*5856*1)
    INTEGER, INTENT(IN) :: fn
    REAL*8, INTENT(OUT) :: inv_t(3*3)
    REAL*8 :: det
    INTEGER :: p
    INTEGER :: d
    INTRINSIC MAX
    INTRINSIC MIN
    d = (fn-1)*(3*3) + 1
    det = faces_t(d+0)*(faces_t(d+4)-faces_t(d+7)) + faces_t(d+3)*(&
&     faces_t(d+7)-faces_t(d+1)) + faces_t(d+6)*(faces_t(d+1)-faces_t(d+&
&     4))
    IF (det .GT. 0) THEN
      IF (det .LT. 1e-10) THEN
        det = 1e-10
      ELSE
        det = det
      END IF
    ELSE IF (det .GT. -1e-10) THEN
      det = -1e-10
    ELSE
      det = det
    END IF
    inv_t(1) = (faces_t(d+4)-faces_t(d+7))/det
    inv_t(2) = (faces_t(d+6)-faces_t(d+3))/det
    inv_t(3) = (faces_t(d+3)*faces_t(d+7)-faces_t(d+6)*faces_t(d+4))/det
    inv_t(4) = (faces_t(d+7)-faces_t(d+1))/det
    inv_t(5) = (faces_t(d+0)-faces_t(d+6))/det
    inv_t(6) = (faces_t(d+6)*faces_t(d+1)-faces_t(d+0)*faces_t(d+7))/det
    inv_t(7) = (faces_t(d+1)-faces_t(d+4))/det
    inv_t(8) = (faces_t(d+3)-faces_t(d+0))/det
    inv_t(9) = (faces_t(d+0)*faces_t(d+4)-faces_t(d+3)*faces_t(d+1))/det
  END SUBROUTINE FACE_INV

!  Differentiation of dot_xy in reverse (adjoint) mode:
!   gradient     of useful results: v1 v2 dot_xy
!   with respect to varying inputs: v1 v2
  SUBROUTINE DOT_XY_B(v1, v1b, v2, v2b, dot_xyb)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: v1(3)
    REAL*8 :: v1b(3)
    REAL*8, INTENT(IN) :: v2(3)
    REAL*8 :: v2b(3)
    REAL*8 :: dot_xy
    REAL*8 :: dot_xyb
    v1b(1) = v1b(1) + v2(1)*dot_xyb
    v2b(1) = v2b(1) + v1(1)*dot_xyb
    v1b(2) = v1b(2) + v2(2)*dot_xyb
    v2b(2) = v2b(2) + v1(2)*dot_xyb
  END SUBROUTINE DOT_XY_B

  REAL*8 FUNCTION DOT_XY(v1, v2)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: v1(3)
    REAL*8, INTENT(IN) :: v2(3)
    dot_xy = v1(1)*v2(1) + v1(2)*v2(2)
  END FUNCTION DOT_XY

!  Differentiation of cross_xy in reverse (adjoint) mode:
!   gradient     of useful results: v1 v2 cross_xy
!   with respect to varying inputs: v1 v2
  SUBROUTINE CROSS_XY_B(v1, v1b, v2, v2b, cross_xyb)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: v1(3)
    REAL*8 :: v1b(3)
    REAL*8, INTENT(IN) :: v2(3)
    REAL*8 :: v2b(3)
    REAL*8 :: cross_xy
    REAL*8 :: cross_xyb
    v1b(1) = v1b(1) + v2(2)*cross_xyb
    v2b(2) = v2b(2) + v1(1)*cross_xyb
    v1b(2) = v1b(2) - v2(1)*cross_xyb
    v2b(1) = v2b(1) - v1(2)*cross_xyb
  END SUBROUTINE CROSS_XY_B

  REAL*8 FUNCTION CROSS_XY(v1, v2)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: v1(3)
    REAL*8, INTENT(IN) :: v2(3)
    cross_xy = v1(1)*v2(2) - v1(2)*v2(1)
  END FUNCTION CROSS_XY

!  Differentiation of sub_xy in reverse (adjoint) mode:
!   gradient     of useful results: v1 v2 v
!   with respect to varying inputs: v1 v2 v
  SUBROUTINE SUB_XY_B(v, vb, v1, v1b, v2, v2b)
    IMPLICIT NONE
    REAL*8 :: v(3)
    REAL*8 :: vb(3)
    REAL*8, INTENT(IN) :: v1(3)
    REAL*8 :: v1b(3)
    REAL*8, INTENT(IN) :: v2(3)
    REAL*8 :: v2b(3)
    INTEGER :: k
    DO k=2,1,-1
      v1b(k) = v1b(k) + vb(k)
      v2b(k) = v2b(k) - vb(k)
      vb(k) = 0.0_8
    END DO
  END SUBROUTINE SUB_XY_B

  SUBROUTINE SUB_XY(v, v1, v2)
    IMPLICIT NONE
    REAL*8, INTENT(OUT) :: v(3)
    REAL*8, INTENT(IN) :: v1(3)
    REAL*8, INTENT(IN) :: v2(3)
    INTEGER :: k
    DO k=1,2
      v(k) = v1(k) - v2(k)
    END DO
  END SUBROUTINE SUB_XY

!  Differentiation of norm2 in reverse (adjoint) mode:
!   gradient     of useful results: v norm2
!   with respect to varying inputs: v
  SUBROUTINE NORM2_B(v, vb, norm2b)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: v(3)
    REAL*8 :: vb(3)
    REAL*8 :: norm2b
    REAL*8 :: norm2
    CALL DOT_XY_B(v, vb, v, vb, norm2b)
  END SUBROUTINE NORM2_B

  REAL*8 FUNCTION NORM2(v)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: v(3)
    norm2 = DOT_XY(v, v)
  END FUNCTION NORM2

!  Differentiation of barycentric_coordinate in reverse (adjoint) mode:
!   gradient     of useful results: w inv
!   with respect to varying inputs: w inv
  SUBROUTINE BARYCENTRIC_COORDINATE_B(w, wb, p, inv, invb)
    IMPLICIT NONE
    REAL*8 :: w(3)
    REAL*8 :: wb(3)
    REAL*8, INTENT(IN) :: p(3)
    REAL*8, INTENT(IN) :: inv(3*3)
    REAL*8 :: invb(3*3)
    INTEGER :: k
    invb(7) = invb(7) + p(1)*wb(3)
    invb(8) = invb(8) + p(2)*wb(3)
    invb(9) = invb(9) + wb(3)
    wb(3) = 0.0_8
    invb(4) = invb(4) + p(1)*wb(2)
    invb(5) = invb(5) + p(2)*wb(2)
    invb(6) = invb(6) + wb(2)
    wb(2) = 0.0_8
    invb(1) = invb(1) + p(1)*wb(1)
    invb(2) = invb(2) + p(2)*wb(1)
    invb(3) = invb(3) + wb(1)
    wb(1) = 0.0_8
  END SUBROUTINE BARYCENTRIC_COORDINATE_B

  SUBROUTINE BARYCENTRIC_COORDINATE(w, p, inv)
    IMPLICIT NONE
    REAL*8, INTENT(OUT) :: w(3)
    REAL*8, INTENT(IN) :: p(3)
    REAL*8, INTENT(IN) :: inv(3*3)
    INTEGER :: k
    w(1) = inv(1)*p(1) + inv(2)*p(2) + inv(3)
    w(2) = inv(4)*p(1) + inv(5)*p(2) + inv(6)
    w(3) = inv(7)*p(1) + inv(8)*p(2) + inv(9)
  END SUBROUTINE BARYCENTRIC_COORDINATE

  LOGICAL FUNCTION CHECK_BORDER(p, faces_t, fn)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: p(3), faces_t(3*3*5856*1)
    INTEGER, INTENT(IN) :: fn
    INTEGER :: d
    REAL*8 :: t
    INTRINSIC SQRT
    INTRINSIC MAX
    INTRINSIC MIN
    REAL*8 :: x1
    REAL*8 :: x2
    REAL*8 :: x3
    REAL*8 :: x4
    REAL*8 :: max1
    REAL*8 :: min1
    REAL*8 :: max2
    REAL*8 :: min2
    d = (fn-1)*(3*3) + 1
    t = SQRT(9.21024036697585*1e-5)
    IF (faces_t(d+0) .LT. faces_t(d+3)) THEN
      x1 = faces_t(d+3)
    ELSE
      x1 = faces_t(d+0)
    END IF
    IF (x1 .LT. faces_t(d+6)) THEN
      max1 = faces_t(d+6)
    ELSE
      max1 = x1
    END IF
    IF (faces_t(d+0) .GT. faces_t(d+3)) THEN
      x2 = faces_t(d+3)
    ELSE
      x2 = faces_t(d+0)
    END IF
    IF (x2 .GT. faces_t(d+6)) THEN
      min1 = faces_t(d+6)
    ELSE
      min1 = x2
    END IF
    IF (faces_t(d+1) .LT. faces_t(d+4)) THEN
      x3 = faces_t(d+4)
    ELSE
      x3 = faces_t(d+1)
    END IF
    IF (x3 .LT. faces_t(d+7)) THEN
      max2 = faces_t(d+7)
    ELSE
      max2 = x3
    END IF
    IF (faces_t(d+1) .GT. faces_t(d+4)) THEN
      x4 = faces_t(d+4)
    ELSE
      x4 = faces_t(d+1)
    END IF
    IF (x4 .GT. faces_t(d+7)) THEN
      min2 = faces_t(d+7)
    ELSE
      min2 = x4
    END IF
    check_border = ((p(1) .GT. max1 + t .OR. p(1) .LT. min1 - t) .OR. p(&
&     2) .GT. max2 + t) .OR. p(2) .LT. min2 - t
  END FUNCTION CHECK_BORDER

  LOGICAL FUNCTION CHECK_FACE_FRONTSIDE(faces_t, fn)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: faces_t(3*3*5856*1)
    INTEGER, INTENT(IN) :: fn
    INTEGER :: d
    d = (fn-1)*(3*3) + 1
    check_face_frontside = (faces_t(d+7)-faces_t(d+1))*(faces_t(d+3)-&
&     faces_t(d+0)) .LT. (faces_t(d+4)-faces_t(d+1))*(faces_t(d+6)-&
&     faces_t(d+0))
  END FUNCTION CHECK_FACE_FRONTSIDE

!  Differentiation of barycentric_clip in reverse (adjoint) mode:
!   gradient     of useful results: w w_clip
!   with respect to varying inputs: w w_clip
  SUBROUTINE BARYCENTRIC_CLIP_B(w_clip, w_clipb, w, wb)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: w(3)
    REAL*8 :: wb(3)
    REAL*8 :: w_clip(3)
    REAL*8 :: w_clipb(3)
    REAL*8 :: w_tmp(3)
    REAL*8 :: w_tmpb(3)
    REAL*8 :: w_sum
    REAL*8 :: w_sumb
    INTEGER :: k
    INTRINSIC MIN
    INTRINSIC MAX
    REAL*8 :: x1
    REAL*8 :: x1b
    INTEGER*4 :: branch
    DO k=1,3
      IF (w(k) .GT. 1.0) THEN
        CALL PUSHCONTROL1B(0)
        x1 = 1.0
      ELSE
        x1 = w(k)
        CALL PUSHCONTROL1B(1)
      END IF
      IF (x1 .LT. 0.0) THEN
        w_tmp(k) = 0.0
        CALL PUSHCONTROL1B(0)
      ELSE
        w_tmp(k) = x1
        CALL PUSHCONTROL1B(1)
      END IF
    END DO
    IF (w_tmp(1) + w_tmp(2) + w_tmp(3) .LT. 1e-5) THEN
      CALL PUSHCONTROL1B(0)
      w_sum = 1e-5
    ELSE
      w_sum = w_tmp(1) + w_tmp(2) + w_tmp(3)
      CALL PUSHCONTROL1B(1)
    END IF
    w_tmpb = 0.0_8
    w_sumb = 0.0_8
    DO k=3,1,-1
      w_tmpb(k) = w_tmpb(k) + w_clipb(k)/w_sum
      w_sumb = w_sumb - w_tmp(k)*w_clipb(k)/w_sum**2
      w_clipb(k) = 0.0_8
    END DO
    CALL POPCONTROL1B(branch)
    IF (branch .NE. 0) THEN
      w_tmpb(1) = w_tmpb(1) + w_sumb
      w_tmpb(2) = w_tmpb(2) + w_sumb
      w_tmpb(3) = w_tmpb(3) + w_sumb
    END IF
    DO k=3,1,-1
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        w_tmpb(k) = 0.0_8
        x1b = 0.0_8
      ELSE
        x1b = w_tmpb(k)
        w_tmpb(k) = 0.0_8
      END IF
      CALL POPCONTROL1B(branch)
      IF (branch .NE. 0) wb(k) = wb(k) + x1b
    END DO
  END SUBROUTINE BARYCENTRIC_CLIP_B

  SUBROUTINE BARYCENTRIC_CLIP(w_clip, w)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: w(3)
    REAL*8, INTENT(OUT) :: w_clip(3)
    REAL*8 :: w_tmp(3)
    REAL*8 :: w_sum
    INTEGER :: k
    INTRINSIC MIN
    INTRINSIC MAX
    REAL*8 :: x1
    DO k=1,3
      IF (w(k) .GT. 1.0) THEN
        x1 = 1.0
      ELSE
        x1 = w(k)
      END IF
      IF (x1 .LT. 0.0) THEN
        w_tmp(k) = 0.0
      ELSE
        w_tmp(k) = x1
      END IF
    END DO
    IF (w_tmp(1) + w_tmp(2) + w_tmp(3) .LT. 1e-5) THEN
      w_sum = 1e-5
    ELSE
      w_sum = w_tmp(1) + w_tmp(2) + w_tmp(3)
    END IF
    DO k=1,3
      w_clip(k) = w_tmp(k)/w_sum
    END DO
  END SUBROUTINE BARYCENTRIC_CLIP

!  Differentiation of euclidean_p2f_distance in reverse (adjoint) mode:
!   gradient     of useful results: faces_t euclidean_p2f_distance
!   with respect to varying inputs: faces_t
  SUBROUTINE EUCLIDEAN_P2F_DISTANCE_B(faces_t, faces_tb, p, fn, &
&   euclidean_p2f_distanceb)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: faces_t(3*3*5856*1), p(3)
    REAL*8 :: faces_tb(3*3*5856*1)
    INTEGER, INTENT(IN) :: fn
    REAL*8 :: dis(3)
    REAL*8 :: disb(3)
    REAL*8, DIMENSION(3) :: tmp0, tmp1, t1, t2, t3
    REAL*8, DIMENSION(3) :: tmp0b, tmp1b, t1b, t2b, t3b
    REAL*8 :: area, d1, d2, len
    REAL*8 :: areab, lenb
    INTEGER :: k, l
    INTEGER :: d
    INTRINSIC MOD
    INTRINSIC MAX
    INTRINSIC MIN
    REAL*8 :: x1
    REAL*8 :: x1b
    REAL*8 :: max1
    REAL*8 :: max1b
    REAL*8, DIMENSION(3) :: pb
    INTEGER*4 :: branch
    REAL*8 :: euclidean_p2f_distanceb
    REAL*8 :: euclidean_p2f_distance
    d = (fn-1)*(3*3) + 1
    DO k=1,3
      tmp0(1) = faces_t(d+(k-1)*3+0)
      tmp0(2) = faces_t(d+(k-1)*3+1)
      tmp1(1) = faces_t(d+MOD(k, 3)*3+0)
      tmp1(2) = faces_t(d+MOD(k, 3)*3+1)
      CALL PUSHREAL8ARRAY(t1, 3)
      CALL SUB_XY(t1, p, tmp0)
      CALL PUSHREAL8ARRAY(t2, 3)
      CALL SUB_XY(t2, tmp1, tmp0)
      CALL PUSHREAL8(area)
      area = CROSS_XY(t1, t2)
      d1 = DOT_XY(t1, t2)
      IF (d1 .GE. 0.0) THEN
        CALL PUSHREAL8ARRAY(t3, 3)
        CALL SUB_XY(t3, tmp1, p)
        d2 = DOT_XY(t2, t3)
        IF (d2 .GE. 0.0) THEN
          len = NORM2(t2)
          IF (len .LT. 1e-10) THEN
            CALL PUSHREAL8(max1)
            max1 = 1e-10
            CALL PUSHCONTROL1B(0)
          ELSE
            CALL PUSHREAL8(max1)
            max1 = len
            CALL PUSHCONTROL1B(1)
          END IF
          dis(k) = area/max1*area
          CALL PUSHCONTROL2B(2)
        ELSE
          dis(k) = NORM2(t3)
          CALL PUSHCONTROL2B(1)
        END IF
      ELSE
        dis(k) = NORM2(t1)
        CALL PUSHCONTROL2B(0)
      END IF
    END DO
    IF (dis(1) .GT. dis(2)) THEN
      x1 = dis(2)
      CALL PUSHCONTROL1B(0)
    ELSE
      x1 = dis(1)
      CALL PUSHCONTROL1B(1)
    END IF
    IF (x1 .GT. dis(3)) THEN
      disb = 0.0_8
      disb(3) = disb(3) + euclidean_p2f_distanceb
      x1b = 0.0_8
    ELSE
      x1b = euclidean_p2f_distanceb
      disb = 0.0_8
    END IF
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      disb(2) = disb(2) + x1b
    ELSE
      disb(1) = disb(1) + x1b
    END IF
    tmp0b = 0.0_8
    tmp1b = 0.0_8
    t1b = 0.0_8
    t2b = 0.0_8
    t3b = 0.0_8
    DO k=3,1,-1
      CALL POPCONTROL2B(branch)
      IF (branch .EQ. 0) THEN
        CALL NORM2_B(t1, t1b, disb(k))
        disb(k) = 0.0_8
        areab = 0.0_8
      ELSE
        IF (branch .EQ. 1) THEN
          CALL NORM2_B(t3, t3b, disb(k))
          disb(k) = 0.0_8
          areab = 0.0_8
        ELSE
          areab = 2*area*disb(k)/max1
          max1b = -(area**2*disb(k)/max1**2)
          disb(k) = 0.0_8
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            CALL POPREAL8(max1)
            lenb = 0.0_8
          ELSE
            CALL POPREAL8(max1)
            lenb = max1b
          END IF
          CALL NORM2_B(t2, t2b, lenb)
        END IF
        CALL POPREAL8ARRAY(t3, 3)
        pb = 0.0_8
        CALL SUB_XY_B(t3, t3b, tmp1, tmp1b, p, pb)
      END IF
      CALL POPREAL8(area)
      CALL CROSS_XY_B(t1, t1b, t2, t2b, areab)
      CALL POPREAL8ARRAY(t2, 3)
      CALL SUB_XY_B(t2, t2b, tmp1, tmp1b, tmp0, tmp0b)
      CALL POPREAL8ARRAY(t1, 3)
      pb = 0.0_8
      CALL SUB_XY_B(t1, t1b, p, pb, tmp0, tmp0b)
      faces_tb(d+MOD(k, 3)*3+1) = faces_tb(d+MOD(k, 3)*3+1) + tmp1b(2)
      tmp1b(2) = 0.0_8
      faces_tb(d+MOD(k, 3)*3+0) = faces_tb(d+MOD(k, 3)*3+0) + tmp1b(1)
      tmp1b(1) = 0.0_8
      faces_tb(d+(k-1)*3+1) = faces_tb(d+(k-1)*3+1) + tmp0b(2)
      tmp0b(2) = 0.0_8
      faces_tb(d+(k-1)*3+0) = faces_tb(d+(k-1)*3+0) + tmp0b(1)
      tmp0b(1) = 0.0_8
    END DO
  END SUBROUTINE EUCLIDEAN_P2F_DISTANCE_B

  REAL*8 FUNCTION EUCLIDEAN_P2F_DISTANCE(faces_t, p, fn)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: faces_t(3*3*5856*1), p(3)
    INTEGER, INTENT(IN) :: fn
    REAL*8 :: dis(3)
    REAL*8, DIMENSION(3) :: tmp0, tmp1, t1, t2, t3
    REAL*8 :: area, d1, d2, len
    INTEGER :: k, l
    INTEGER :: d
    INTRINSIC MOD
    INTRINSIC MAX
    INTRINSIC MIN
    REAL*8 :: x1
    REAL*8 :: max1
    d = (fn-1)*(3*3) + 1
    DO k=1,3
      tmp0(1) = faces_t(d+(k-1)*3+0)
      tmp0(2) = faces_t(d+(k-1)*3+1)
      tmp1(1) = faces_t(d+MOD(k, 3)*3+0)
      tmp1(2) = faces_t(d+MOD(k, 3)*3+1)
      CALL SUB_XY(t1, p, tmp0)
      CALL SUB_XY(t2, tmp1, tmp0)
      area = CROSS_XY(t1, t2)
      d1 = DOT_XY(t1, t2)
      IF (d1 .GE. 0.0) THEN
        CALL SUB_XY(t3, tmp1, p)
        d2 = DOT_XY(t2, t3)
        IF (d2 .GE. 0.0) THEN
          len = NORM2(t2)
          IF (len .LT. 1e-10) THEN
            max1 = 1e-10
          ELSE
            max1 = len
          END IF
          dis(k) = area/max1*area
        ELSE
          dis(k) = NORM2(t3)
        END IF
      ELSE
        dis(k) = NORM2(t1)
      END IF
    END DO
    IF (dis(1) .GT. dis(2)) THEN
      x1 = dis(2)
    ELSE
      x1 = dis(1)
    END IF
    IF (x1 .GT. dis(3)) THEN
      euclidean_p2f_distance = dis(3)
    ELSE
      euclidean_p2f_distance = x1
    END IF
  END FUNCTION EUCLIDEAN_P2F_DISTANCE

!  Differentiation of forward_sample_texture in reverse (adjoint) mode:
!   gradient     of useful results: forward_sample_texture textures_t
!   with respect to varying inputs: textures_t
  SUBROUTINE FORWARD_SAMPLE_TEXTURE_B(textures_t, textures_tb, w, r, k, &
&   fn, forward_sample_textureb)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: textures_t(3*25*5856*1), w(3)
    REAL*8 :: textures_tb(3*25*5856*1)
    INTEGER, INTENT(IN) :: r, k, fn
    INTEGER :: w_x, w_y
    INTEGER :: d
    REAL*8 :: texture_k
    REAL*8 :: texture_kb
    INTRINSIC INT
    INTEGER*4 :: branch
    REAL*8 :: forward_sample_texture
    REAL*8 :: forward_sample_textureb
    d = (fn-1)*(25*3)
    w_x = INT(w(1)*r)
    w_y = INT(w(2)*r)
    IF ((w(1)+w(2))*r - w_x - w_y .LE. 1) THEN
      IF (w_y*r + w_x .EQ. 25) THEN
        CALL PUSHCONTROL2B(0)
      ELSE
        CALL PUSHCONTROL2B(1)
      END IF
    ELSE
      CALL PUSHCONTROL2B(2)
    END IF
    texture_kb = forward_sample_textureb
    CALL POPCONTROL2B(branch)
    IF (branch .EQ. 0) THEN
      textures_tb(d+(w_y*r+w_x-1)*3+k) = textures_tb(d+(w_y*r+w_x-1)*3+k&
&       ) + texture_kb
    ELSE IF (branch .EQ. 1) THEN
      textures_tb(d+(w_y*r+w_x)*3+k) = textures_tb(d+(w_y*r+w_x)*3+k) + &
&       texture_kb
    ELSE
      textures_tb(d+((r-1-w_y)*r+(r-1-w_x))*3+k) = textures_tb(d+((r-1-&
&       w_y)*r+(r-1-w_x))*3+k) + texture_kb
    END IF
  END SUBROUTINE FORWARD_SAMPLE_TEXTURE_B

  REAL*8 FUNCTION FORWARD_SAMPLE_TEXTURE(textures_t, w, r, k, fn)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: textures_t(3*25*5856*1), w(3)
    INTEGER, INTENT(IN) :: r, k, fn
    INTEGER :: w_x, w_y
    INTEGER :: d
    REAL*8 :: texture_k
    INTRINSIC INT
    d = (fn-1)*(25*3)
    w_x = INT(w(1)*r)
    w_y = INT(w(2)*r)
    IF ((w(1)+w(2))*r - w_x - w_y .LE. 1) THEN
      IF (w_y*r + w_x .EQ. 25) THEN
        texture_k = textures_t(d+(w_y*r+w_x-1)*3+k)
      ELSE
        texture_k = textures_t(d+(w_y*r+w_x)*3+k)
      END IF
    ELSE
      texture_k = textures_t(d+((r-1-w_y)*r+(r-1-w_x))*3+k)
    END IF
    forward_sample_texture = texture_k
  END FUNCTION FORWARD_SAMPLE_TEXTURE

!  Differentiation of tapenade_render_main in reverse (adjoint) mode:
!   gradient     of useful results: soft_colors_t
!   with respect to varying inputs: faces_t soft_colors_t textures_t
!   RW status of diff variables: faces_t:out soft_colors_t:in-out
!                textures_t:out
  SUBROUTINE TAPENADE_RENDER_MAIN_B(soft_colors_t, soft_colors_tb, &
&   faces_t, faces_tb, textures_t, textures_tb) BIND(c)
    IMPLICIT NONE
    REAL*8 :: soft_colors_t(256*256*4*1)
    REAL*8 :: soft_colors_tb(256*256*4*1)
    REAL*8, INTENT(IN) :: faces_t(3*3*5856*1)
    REAL*8 :: faces_tb(3*3*5856*1)
    REAL*8, INTENT(IN) :: textures_t(3*25*5856*1)
    REAL*8 :: textures_tb(3*25*5856*1)
    INTEGER :: pn, yi, xi, fn, k, d
    REAL*8, DIMENSION(3) :: pixel
    REAL*8, DIMENSION(3*3) :: inv
    REAL*8, DIMENSION(3*3) :: invb
    REAL*8, DIMENSION(3) :: w, w_clip
    REAL*8, DIMENSION(3) :: wb, w_clipb
    REAL*8, DIMENSION(3) :: soft_color
    REAL*8, DIMENSION(3) :: soft_colorb
    REAL*8, DIMENSION(5856) :: soft_color_alpha
    REAL*8, DIMENSION(5856) :: soft_color_alphab
    REAL*8 :: sign, softmax_max, softmax_sum, zp, zp_norm, coef, color_k&
&   , soft_fragment, dis
    REAL*8 :: softmax_maxb, softmax_sumb, zpb, zp_normb, coefb, color_kb&
&   , soft_fragmentb, disb
    INTRINSIC INT
    INTRINSIC MOD
    INTRINSIC EXP
    LOGICAL :: result1
    REAL*8 :: temp
    REAL*8 :: temp0
    REAL*8 :: temp1
    REAL*8 :: temp2
    REAL*8 :: tempb
    REAL*8 :: tempb0
    REAL*8 :: tempb1
    REAL*8 :: tempb2
    INTEGER*4 :: branch
    DO pn=1,256*256
      yi = 256 - 1 - INT((pn-1)/256)
      xi = MOD(pn - 1, 256)
      CALL PUSHREAL8(pixel(1))
      pixel(1) = (2.0*xi+1.0-256)/256
      CALL PUSHREAL8(pixel(2))
      pixel(2) = (2.0*yi+1.0-256)/256
      CALL PUSHREAL8(softmax_max)
      softmax_max = 1e-3
      CALL PUSHREAL8(soft_color_alpha(1))
      soft_color_alpha(1) = 1.0
      DO fn=1,5856
        d = (fn-1)*(3*3) + 1
        CALL FACE_INV(inv, faces_t, fn)
        result1 = CHECK_BORDER(pixel, faces_t, fn)
        IF (.NOT.result1) THEN
          CALL PUSHREAL8ARRAY(w, 3)
          CALL BARYCENTRIC_COORDINATE(w, pixel, inv)
          CALL PUSHREAL8ARRAY(w_clip, 3)
          CALL BARYCENTRIC_CLIP(w_clip, w)
          zp = 1.0/(w_clip(1)/faces_t(d+2)+w_clip(2)/faces_t(d+5)+w_clip&
&           (3)/faces_t(d+8))
          IF (.NOT.(zp .LT. 1.0 .OR. zp .GT. 100.0)) THEN
            result1 = CHECK_FACE_FRONTSIDE(faces_t, fn)
            IF (result1) THEN
              CALL PUSHREAL8(zp_norm)
              zp_norm = (100.0-zp)/(100.0-1.0)
              IF (zp_norm .GT. softmax_max) THEN
                softmax_max = zp_norm
                CALL PUSHCONTROL3B(4)
              ELSE
                CALL PUSHCONTROL3B(3)
              END IF
            ELSE
              CALL PUSHCONTROL3B(2)
            END IF
          ELSE
            CALL PUSHCONTROL3B(1)
          END IF
        ELSE
          CALL PUSHCONTROL3B(0)
        END IF
      END DO
      CALL PUSHREAL8(softmax_sum)
      softmax_sum = EXP((2*1e-3-softmax_max)/1e-4)
      DO k=1,3
        CALL PUSHREAL8(soft_color(k))
        soft_color(k) = 0.0*softmax_sum
      END DO
      DO fn=1,5856
        d = (fn-1)*(3*3) + 1
        IF (fn .GT. 1) THEN
          CALL PUSHREAL8(soft_color_alpha(fn))
          soft_color_alpha(fn) = soft_color_alpha(fn-1)
          CALL PUSHCONTROL1B(0)
        ELSE
          CALL PUSHCONTROL1B(1)
        END IF
        CALL FACE_INV(inv, faces_t, fn)
        result1 = CHECK_BORDER(pixel, faces_t, fn)
        IF (.NOT.result1) THEN
          CALL PUSHREAL8ARRAY(w, 3)
          CALL BARYCENTRIC_COORDINATE(w, pixel, inv)
          IF (w(1) .GT. 0 .AND. w(2) .GT. 0 .AND. w(3) .GT. 0 .AND. w(1)&
&             .LT. 1 .AND. w(2) .LT. 1 .AND. w(3) .LT. 1) THEN
            CALL PUSHREAL8(sign)
            sign = 1.0
            CALL PUSHCONTROL1B(0)
          ELSE
            CALL PUSHREAL8(sign)
            sign = -1.0
            CALL PUSHCONTROL1B(1)
          END IF
          CALL PUSHREAL8(dis)
          dis = EUCLIDEAN_P2F_DISTANCE(faces_t, pixel, fn)
          IF (.NOT.(sign .LT. 0.0 .AND. dis .GE. 9.21024036697585*1e-5)&
&         ) THEN
            CALL PUSHREAL8(soft_fragment)
            soft_fragment = 1.0/(1.0+EXP(-(sign*dis/1e-5)))
            IF (fn .GT. 1) THEN
              CALL PUSHREAL8(soft_color_alpha(fn))
              soft_color_alpha(fn) = soft_color_alpha(fn-1)*(1.0-&
&               soft_fragment)
              CALL PUSHCONTROL1B(0)
            ELSE
              CALL PUSHREAL8(soft_color_alpha(fn))
              soft_color_alpha(fn) = 1.0 - soft_fragment
              CALL PUSHCONTROL1B(1)
            END IF
            CALL PUSHREAL8ARRAY(w_clip, 3)
            CALL BARYCENTRIC_CLIP(w_clip, w)
            zp = 1.0/(w_clip(1)/faces_t(d+2)+w_clip(2)/faces_t(d+5)+&
&             w_clip(3)/faces_t(d+8))
            IF (.NOT.(zp .LT. 1.0 .OR. zp .GT. 100.0)) THEN
              result1 = CHECK_FACE_FRONTSIDE(faces_t, fn)
              IF (result1) THEN
                CALL PUSHREAL8(zp_norm)
                zp_norm = (100.0-zp)/(100.0-1.0)
                CALL PUSHREAL8(coef)
                coef = EXP((zp_norm-softmax_max)/1e-4)*soft_fragment
                softmax_sum = softmax_sum + coef
                DO k=1,3
                  CALL PUSHREAL8(color_k)
                  color_k = FORWARD_SAMPLE_TEXTURE(textures_t, w_clip, 5&
&                   , k, fn)
                  soft_color(k) = soft_color(k) + coef*color_k
                END DO
                CALL PUSHCONTROL3B(4)
              ELSE
                CALL PUSHCONTROL3B(3)
              END IF
            ELSE
              CALL PUSHCONTROL3B(2)
            END IF
          ELSE
            CALL PUSHCONTROL3B(1)
          END IF
        ELSE
          CALL PUSHCONTROL3B(0)
        END IF
      END DO
    END DO
    faces_tb = 0.0_8
    textures_tb = 0.0_8
    soft_color_alphab = 0.0_8
    wb = 0.0_8
    soft_colorb = 0.0_8
    w_clipb = 0.0_8
    invb = 0.0_8
    DO pn=65536,1,-1
      softmax_sumb = 0.0_8
      DO k=3,1,-1
        soft_colorb(k) = soft_colorb(k) + soft_colors_tb((k-1)*(256*256)&
&         +pn)/softmax_sum
        softmax_sumb = softmax_sumb - soft_color(k)*soft_colors_tb((k-1)&
&         *(256*256)+pn)/softmax_sum**2
        soft_colors_tb((k-1)*(256*256)+pn) = 0.0_8
      END DO
      soft_color_alphab(5856) = soft_color_alphab(5856) - soft_colors_tb&
&       ((4-1)*(256*256)+pn)
      soft_colors_tb((4-1)*(256*256)+pn) = 0.0_8
      softmax_maxb = 0.0_8
      DO fn=5856,1,-1
        CALL POPCONTROL3B(branch)
        IF (branch .LT. 2) THEN
          IF (branch .EQ. 0) THEN
            GOTO 100
          ELSE
            disb = 0.0_8
          END IF
        ELSE
          IF (branch .EQ. 2) THEN
            soft_fragmentb = 0.0_8
            zpb = 0.0_8
          ELSE IF (branch .EQ. 3) THEN
            soft_fragmentb = 0.0_8
            zpb = 0.0_8
          ELSE
            coefb = 0.0_8
            DO k=3,1,-1
              coefb = coefb + color_k*soft_colorb(k)
              color_kb = coef*soft_colorb(k)
              CALL POPREAL8(color_k)
              CALL FORWARD_SAMPLE_TEXTURE_B(textures_t, textures_tb, &
&                                     w_clip, 5, k, fn, color_kb)
            END DO
            coefb = coefb + softmax_sumb
            CALL POPREAL8(coef)
            temp2 = (zp_norm-softmax_max)/1e-4
            tempb = EXP(temp2)*soft_fragment*coefb/1e-4
            soft_fragmentb = EXP(temp2)*coefb
            zp_normb = tempb
            softmax_maxb = softmax_maxb - tempb
            CALL POPREAL8(zp_norm)
            zpb = -(zp_normb/99.0)
          END IF
          d = (fn-1)*(3*3) + 1
          temp2 = w_clip(3)/faces_t(d+8)
          temp1 = w_clip(2)/faces_t(d+5)
          temp0 = w_clip(1)/faces_t(d+2)
          temp = temp0 + temp1 + temp2
          tempb2 = -(zpb/temp**2)
          tempb1 = tempb2/faces_t(d+2)
          tempb0 = tempb2/faces_t(d+5)
          tempb = tempb2/faces_t(d+8)
          w_clipb(3) = w_clipb(3) + tempb
          faces_tb(d+8) = faces_tb(d+8) - temp2*tempb
          w_clipb(2) = w_clipb(2) + tempb0
          faces_tb(d+5) = faces_tb(d+5) - temp1*tempb0
          w_clipb(1) = w_clipb(1) + tempb1
          faces_tb(d+2) = faces_tb(d+2) - temp0*tempb1
          CALL POPREAL8ARRAY(w_clip, 3)
          CALL BARYCENTRIC_CLIP_B(w_clip, w_clipb, w, wb)
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            CALL POPREAL8(soft_color_alpha(fn))
            soft_color_alphab(fn-1) = soft_color_alphab(fn-1) + (1.0-&
&             soft_fragment)*soft_color_alphab(fn)
            soft_fragmentb = soft_fragmentb - soft_color_alpha(fn-1)*&
&             soft_color_alphab(fn)
            soft_color_alphab(fn) = 0.0_8
          ELSE
            CALL POPREAL8(soft_color_alpha(fn))
            soft_fragmentb = soft_fragmentb - soft_color_alphab(fn)
            soft_color_alphab(fn) = 0.0_8
          END IF
          CALL POPREAL8(soft_fragment)
          temp2 = -(sign*dis/1e-5)
          temp1 = EXP(temp2) + 1.0
          disb = sign*EXP(temp2)*soft_fragmentb/(1e-5*temp1**2)
        END IF
        CALL POPREAL8(dis)
        CALL EUCLIDEAN_P2F_DISTANCE_B(faces_t, faces_tb, pixel, fn, disb&
&                              )
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          CALL POPREAL8(sign)
        ELSE
          CALL POPREAL8(sign)
        END IF
        CALL POPREAL8ARRAY(w, 3)
        CALL BARYCENTRIC_COORDINATE_B(w, wb, pixel, inv, invb)
 100    CALL FACE_INV_B(inv, invb, faces_t, faces_tb, fn)
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          CALL POPREAL8(soft_color_alpha(fn))
          soft_color_alphab(fn-1) = soft_color_alphab(fn-1) + &
&           soft_color_alphab(fn)
          soft_color_alphab(fn) = 0.0_8
        END IF
      END DO
      DO k=3,1,-1
        CALL POPREAL8(soft_color(k))
        soft_colorb(k) = 0.0_8
      END DO
      CALL POPREAL8(softmax_sum)
      softmax_maxb = softmax_maxb - EXP((2*1e-3-softmax_max)/1e-4)*&
&       softmax_sumb/1e-4
      DO fn=5856,1,-1
        CALL POPCONTROL3B(branch)
        IF (branch .LT. 2) THEN
          IF (branch .EQ. 0) THEN
            GOTO 110
          ELSE
            zpb = 0.0_8
          END IF
        ELSE IF (branch .EQ. 2) THEN
          zpb = 0.0_8
        ELSE
          IF (branch .EQ. 3) THEN
            zp_normb = 0.0_8
          ELSE
            zp_normb = softmax_maxb
            softmax_maxb = 0.0_8
          END IF
          CALL POPREAL8(zp_norm)
          zpb = -(zp_normb/99.0)
        END IF
        d = (fn-1)*(3*3) + 1
        temp = w_clip(3)/faces_t(d+8)
        temp0 = w_clip(2)/faces_t(d+5)
        temp1 = w_clip(1)/faces_t(d+2)
        temp2 = temp1 + temp0 + temp
        tempb = -(zpb/temp2**2)
        tempb0 = tempb/faces_t(d+2)
        tempb1 = tempb/faces_t(d+5)
        tempb2 = tempb/faces_t(d+8)
        w_clipb(3) = w_clipb(3) + tempb2
        faces_tb(d+8) = faces_tb(d+8) - temp*tempb2
        w_clipb(2) = w_clipb(2) + tempb1
        faces_tb(d+5) = faces_tb(d+5) - temp0*tempb1
        w_clipb(1) = w_clipb(1) + tempb0
        faces_tb(d+2) = faces_tb(d+2) - temp1*tempb0
        CALL POPREAL8ARRAY(w_clip, 3)
        CALL BARYCENTRIC_CLIP_B(w_clip, w_clipb, w, wb)
        CALL POPREAL8ARRAY(w, 3)
        CALL BARYCENTRIC_COORDINATE_B(w, wb, pixel, inv, invb)
 110    CALL FACE_INV_B(inv, invb, faces_t, faces_tb, fn)
      END DO
      CALL POPREAL8(soft_color_alpha(1))
      soft_color_alphab(1) = 0.0_8
      DO k=3,1,-1
        soft_colorb(k) = 0.0_8
      END DO
      CALL POPREAL8(softmax_max)
      CALL POPREAL8(pixel(2))
      CALL POPREAL8(pixel(1))
    END DO
  END SUBROUTINE TAPENADE_RENDER_MAIN_B

  SUBROUTINE TAPENADE_RENDER_MAIN(soft_colors_t, faces_t, textures_t) &
& BIND(c)
    IMPLICIT NONE
    REAL*8, INTENT(OUT) :: soft_colors_t(256*256*4*1)
    REAL*8, INTENT(IN) :: faces_t(3*3*5856*1)
    REAL*8, INTENT(IN) :: textures_t(3*25*5856*1)
    INTEGER :: pn, yi, xi, fn, k, d
    REAL*8, DIMENSION(3) :: pixel
    REAL*8, DIMENSION(3*3) :: inv
    REAL*8, DIMENSION(3) :: w, w_clip
    REAL*8, DIMENSION(3) :: soft_color
    REAL*8, DIMENSION(5856) :: soft_color_alpha
    REAL*8 :: sign, softmax_max, softmax_sum, zp, zp_norm, coef, color_k&
&   , soft_fragment, dis
    INTRINSIC INT
    INTRINSIC MOD
    INTRINSIC EXP
    LOGICAL :: result1
    DO pn=1,256*256
      yi = 256 - 1 - INT((pn-1)/256)
      xi = MOD(pn - 1, 256)
      pixel(1) = (2.0*xi+1.0-256)/256
      pixel(2) = (2.0*yi+1.0-256)/256
      softmax_max = 1e-3
      DO k=1,3
        soft_color(k) = 0.0
      END DO
      soft_color_alpha(1) = 1.0
      DO fn=1,5856
        d = (fn-1)*(3*3) + 1
        CALL FACE_INV(inv, faces_t, fn)
        result1 = CHECK_BORDER(pixel, faces_t, fn)
        IF (.NOT.result1) THEN
          CALL BARYCENTRIC_COORDINATE(w, pixel, inv)
          CALL BARYCENTRIC_CLIP(w_clip, w)
          zp = 1.0/(w_clip(1)/faces_t(d+2)+w_clip(2)/faces_t(d+5)+w_clip&
&           (3)/faces_t(d+8))
          IF (.NOT.(zp .LT. 1.0 .OR. zp .GT. 100.0)) THEN
            result1 = CHECK_FACE_FRONTSIDE(faces_t, fn)
            IF (result1) THEN
              zp_norm = (100.0-zp)/(100.0-1.0)
              IF (zp_norm .GT. softmax_max) softmax_max = zp_norm
            END IF
          END IF
        END IF
      END DO
      softmax_sum = EXP((2*1e-3-softmax_max)/1e-4)
      DO k=1,3
        soft_color(k) = 0.0*softmax_sum
      END DO
      DO fn=1,5856
        d = (fn-1)*(3*3) + 1
        IF (fn .GT. 1) soft_color_alpha(fn) = soft_color_alpha(fn-1)
        CALL FACE_INV(inv, faces_t, fn)
        result1 = CHECK_BORDER(pixel, faces_t, fn)
        IF (.NOT.result1) THEN
          CALL BARYCENTRIC_COORDINATE(w, pixel, inv)
          IF (w(1) .GT. 0 .AND. w(2) .GT. 0 .AND. w(3) .GT. 0 .AND. w(1)&
&             .LT. 1 .AND. w(2) .LT. 1 .AND. w(3) .LT. 1) THEN
            sign = 1.0
          ELSE
            sign = -1.0
          END IF
          dis = EUCLIDEAN_P2F_DISTANCE(faces_t, pixel, fn)
          IF (.NOT.(sign .LT. 0.0 .AND. dis .GE. 9.21024036697585*1e-5)&
&         ) THEN
            soft_fragment = 1.0/(1.0+EXP(-(sign*dis/1e-5)))
            IF (fn .GT. 1) THEN
              soft_color_alpha(fn) = soft_color_alpha(fn-1)*(1.0-&
&               soft_fragment)
            ELSE
              soft_color_alpha(fn) = 1.0 - soft_fragment
            END IF
            CALL BARYCENTRIC_CLIP(w_clip, w)
            zp = 1.0/(w_clip(1)/faces_t(d+2)+w_clip(2)/faces_t(d+5)+&
&             w_clip(3)/faces_t(d+8))
            IF (.NOT.(zp .LT. 1.0 .OR. zp .GT. 100.0)) THEN
              result1 = CHECK_FACE_FRONTSIDE(faces_t, fn)
              IF (result1) THEN
                zp_norm = (100.0-zp)/(100.0-1.0)
                coef = EXP((zp_norm-softmax_max)/1e-4)*soft_fragment
                softmax_sum = softmax_sum + coef
                DO k=1,3
                  color_k = FORWARD_SAMPLE_TEXTURE(textures_t, w_clip, 5&
&                   , k, fn)
                  soft_color(k) = soft_color(k) + coef*color_k
                END DO
              END IF
            END IF
          END IF
        END IF
      END DO
      soft_colors_t((4-1)*(256*256)+pn) = 1.0 - soft_color_alpha(5856)
      DO k=1,3
        soft_colors_t((k-1)*(256*256)+pn) = soft_color(k)/softmax_sum
      END DO
    END DO
  END SUBROUTINE TAPENADE_RENDER_MAIN

END MODULE TAPENADE_RENDER_DIFF

