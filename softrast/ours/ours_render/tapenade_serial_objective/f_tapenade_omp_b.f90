!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.16 (develop) - 14 Jul 2023 15:27
!
MODULE TAPENADE_RENDER_DIFF
  IMPLICIT NONE
! Macro Definitions
  INTEGER, PARAMETER :: batch_size=1
  INTEGER, PARAMETER :: num_faces=5856
  INTEGER, PARAMETER :: texture_size=25
  INTEGER, PARAMETER :: texture_res=5
  INTEGER, PARAMETER :: image_size=256
  REAL*4, PARAMETER :: near=1.0
  REAL*4, PARAMETER :: far=100.0
  REAL*4, PARAMETER :: eps=1e-3
  REAL*4, PARAMETER :: sigma_val=1e-5
  REAL*4, PARAMETER :: gamma_val=1e-4
  REAL*4, PARAMETER :: dist_eps=9.21024036697585
  REAL*4, PARAMETER :: threshold=dist_eps*sigma_val
  LOGICAL, PARAMETER :: double_side=.false.
  INTEGER, PARAMETER :: texture_type=0

CONTAINS
! Function and Subroutine Declarations
  INTEGER FUNCTION MOD_INDEX(a, p)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: a, p
    INTRINSIC MOD
    mod_index = MOD(a, p) + 1
  END FUNCTION MOD_INDEX

!  Differentiation of face_inv in reverse (adjoint) mode (with options OpenMP):
!   gradient     of useful results: faces_t inv_t
!   with respect to varying inputs: faces_t inv_t
  SUBROUTINE FACE_INV_B(inv_t, inv_tb, faces_t, faces_tb, fn, bn)
    IMPLICIT NONE
    REAL*4, INTENT(IN) :: faces_t(3*3*num_faces*batch_size)
    REAL*4 :: faces_tb(3*3*num_faces*batch_size)
    INTEGER, INTENT(IN) :: fn, bn
    REAL*4 :: inv_t(3*3)
    REAL*4 :: inv_tb(3*3)
    REAL*4 :: det
    REAL*4 :: detb
    INTEGER :: p
    INTEGER :: d
    INTRINSIC MAX
    INTRINSIC MIN
    REAL*4 :: tempb
    REAL*4 :: tempb0
    REAL*4 :: tempb1
    INTEGER :: ad_branch
    d = (bn-1)*(num_faces*3*3) + (fn-1)*(3*3) + 1
    det = faces_t(d+0)*(faces_t(d+4)-faces_t(d+7)) + faces_t(d+3)*(&
&     faces_t(d+7)-faces_t(d+1)) + faces_t(d+6)*(faces_t(d+1)-faces_t(d+&
&     4))
    IF (det .GT. 0) THEN
      IF (det .LT. 1e-10) THEN
        det = 1e-10
        ad_branch = 1
      ELSE
        ad_branch = 0
        det = det
      END IF
    ELSE IF (det .GT. -1e-10) THEN
      det = -1e-10
      ad_branch = 3
    ELSE
      ad_branch = 2
      det = det
    END IF
    tempb1 = inv_tb(9)/det
    inv_tb(9) = 0.0_4
!$OMP ATOMIC update
    faces_tb(d+0) = faces_tb(d+0) + faces_t(d+4)*tempb1
!$OMP ATOMIC update
    faces_tb(d+4) = faces_tb(d+4) + faces_t(d+0)*tempb1
!$OMP ATOMIC update
    faces_tb(d+3) = faces_tb(d+3) - faces_t(d+1)*tempb1
!$OMP ATOMIC update
    faces_tb(d+1) = faces_tb(d+1) - faces_t(d+3)*tempb1
    detb = -((faces_t(d+0)*faces_t(d+4)-faces_t(d+3)*faces_t(d+1))*&
&     tempb1/det)
    tempb1 = inv_tb(8)/det
    inv_tb(8) = 0.0_4
!$OMP ATOMIC update
    faces_tb(d+3) = faces_tb(d+3) + tempb1
!$OMP ATOMIC update
    faces_tb(d+0) = faces_tb(d+0) - tempb1
    detb = detb - (faces_t(d+3)-faces_t(d+0))*tempb1/det
    tempb1 = inv_tb(7)/det
    inv_tb(7) = 0.0_4
!$OMP ATOMIC update
    faces_tb(d+1) = faces_tb(d+1) + tempb1
!$OMP ATOMIC update
    faces_tb(d+4) = faces_tb(d+4) - tempb1
    detb = detb - (faces_t(d+1)-faces_t(d+4))*tempb1/det
    tempb1 = inv_tb(6)/det
    inv_tb(6) = 0.0_4
!$OMP ATOMIC update
    faces_tb(d+6) = faces_tb(d+6) + faces_t(d+1)*tempb1
!$OMP ATOMIC update
    faces_tb(d+1) = faces_tb(d+1) + faces_t(d+6)*tempb1
!$OMP ATOMIC update
    faces_tb(d+0) = faces_tb(d+0) - faces_t(d+7)*tempb1
!$OMP ATOMIC update
    faces_tb(d+7) = faces_tb(d+7) - faces_t(d+0)*tempb1
    detb = detb - (faces_t(d+6)*faces_t(d+1)-faces_t(d+0)*faces_t(d+7))*&
&     tempb1/det
    tempb1 = inv_tb(5)/det
    inv_tb(5) = 0.0_4
!$OMP ATOMIC update
    faces_tb(d+0) = faces_tb(d+0) + tempb1
!$OMP ATOMIC update
    faces_tb(d+6) = faces_tb(d+6) - tempb1
    detb = detb - (faces_t(d+0)-faces_t(d+6))*tempb1/det
    tempb1 = inv_tb(4)/det
    inv_tb(4) = 0.0_4
!$OMP ATOMIC update
    faces_tb(d+7) = faces_tb(d+7) + tempb1
!$OMP ATOMIC update
    faces_tb(d+1) = faces_tb(d+1) - tempb1
    detb = detb - (faces_t(d+7)-faces_t(d+1))*tempb1/det
    tempb1 = inv_tb(3)/det
    inv_tb(3) = 0.0_4
!$OMP ATOMIC update
    faces_tb(d+3) = faces_tb(d+3) + faces_t(d+7)*tempb1
!$OMP ATOMIC update
    faces_tb(d+7) = faces_tb(d+7) + faces_t(d+3)*tempb1
!$OMP ATOMIC update
    faces_tb(d+6) = faces_tb(d+6) - faces_t(d+4)*tempb1
!$OMP ATOMIC update
    faces_tb(d+4) = faces_tb(d+4) - faces_t(d+6)*tempb1
    detb = detb - (faces_t(d+3)*faces_t(d+7)-faces_t(d+6)*faces_t(d+4))*&
&     tempb1/det
    tempb1 = inv_tb(2)/det
    inv_tb(2) = 0.0_4
!$OMP ATOMIC update
    faces_tb(d+6) = faces_tb(d+6) + tempb1
!$OMP ATOMIC update
    faces_tb(d+3) = faces_tb(d+3) - tempb1
    detb = detb - (faces_t(d+6)-faces_t(d+3))*tempb1/det
    tempb1 = inv_tb(1)/det
    inv_tb(1) = 0.0_4
!$OMP ATOMIC update
    faces_tb(d+4) = faces_tb(d+4) + tempb1
!$OMP ATOMIC update
    faces_tb(d+7) = faces_tb(d+7) - tempb1
    detb = detb - (faces_t(d+4)-faces_t(d+7))*tempb1/det
    IF (ad_branch .LT. 2) THEN
      IF (ad_branch .NE. 0) detb = 0.0_4
    ELSE IF (ad_branch .NE. 2) THEN
      detb = 0.0_4
    END IF
!$OMP ATOMIC update
    faces_tb(d+0) = faces_tb(d+0) + (faces_t(d+4)-faces_t(d+7))*detb
    tempb = faces_t(d+0)*detb
!$OMP ATOMIC update
    faces_tb(d+3) = faces_tb(d+3) + (faces_t(d+7)-faces_t(d+1))*detb
    tempb0 = faces_t(d+3)*detb
!$OMP ATOMIC update
    faces_tb(d+6) = faces_tb(d+6) + (faces_t(d+1)-faces_t(d+4))*detb
    tempb1 = faces_t(d+6)*detb
!$OMP ATOMIC update
    faces_tb(d+1) = faces_tb(d+1) + tempb1 - tempb0
!$OMP ATOMIC update
    faces_tb(d+4) = faces_tb(d+4) + tempb - tempb1
!$OMP ATOMIC update
    faces_tb(d+7) = faces_tb(d+7) + tempb0 - tempb
  END SUBROUTINE FACE_INV_B

  SUBROUTINE FACE_INV(inv_t, faces_t, fn, bn)
    IMPLICIT NONE
    REAL*4, INTENT(IN) :: faces_t(3*3*num_faces*batch_size)
    INTEGER, INTENT(IN) :: fn, bn
    REAL*4, INTENT(OUT) :: inv_t(3*3)
    REAL*4 :: det
    INTEGER :: p
    INTEGER :: d
    INTRINSIC MAX
    INTRINSIC MIN
    d = (bn-1)*(num_faces*3*3) + (fn-1)*(3*3) + 1
    det = faces_t(d+0)*(faces_t(d+4)-faces_t(d+7)) + faces_t(d+3)*(&
&     faces_t(d+7)-faces_t(d+1)) + faces_t(d+6)*(faces_t(d+1)-faces_t(d+&
&     4))
    IF (det .GT. 0) THEN
      IF (det .LT. 1e-10) THEN
        det = 1e-10
      ELSE
        det = det
      END IF
    ELSE IF (det .GT. -1e-10) THEN
      det = -1e-10
    ELSE
      det = det
    END IF
    inv_t(1) = (faces_t(d+4)-faces_t(d+7))/det
    inv_t(2) = (faces_t(d+6)-faces_t(d+3))/det
    inv_t(3) = (faces_t(d+3)*faces_t(d+7)-faces_t(d+6)*faces_t(d+4))/det
    inv_t(4) = (faces_t(d+7)-faces_t(d+1))/det
    inv_t(5) = (faces_t(d+0)-faces_t(d+6))/det
    inv_t(6) = (faces_t(d+6)*faces_t(d+1)-faces_t(d+0)*faces_t(d+7))/det
    inv_t(7) = (faces_t(d+1)-faces_t(d+4))/det
    inv_t(8) = (faces_t(d+3)-faces_t(d+0))/det
    inv_t(9) = (faces_t(d+0)*faces_t(d+4)-faces_t(d+3)*faces_t(d+1))/det
  END SUBROUTINE FACE_INV

!  Differentiation of dot_xy in reverse (adjoint) mode (with options OpenMP):
!   gradient     of useful results: v1 v2 dot_xy
!   with respect to varying inputs: v1 v2
  SUBROUTINE DOT_XY_B(v1, v1b, v2, v2b, dot_xyb)
    IMPLICIT NONE
    REAL*4, INTENT(IN) :: v1(3)
    REAL*4 :: v1b(3)
    REAL*4, INTENT(IN) :: v2(3)
    REAL*4 :: v2b(3)
    REAL*4 :: dot_xy
    REAL*4 :: dot_xyb
    v1b(1) = v1b(1) + v2(1)*dot_xyb
    v2b(1) = v2b(1) + v1(1)*dot_xyb
    v1b(2) = v1b(2) + v2(2)*dot_xyb
    v2b(2) = v2b(2) + v1(2)*dot_xyb
  END SUBROUTINE DOT_XY_B

  REAL*4 FUNCTION DOT_XY(v1, v2)
    IMPLICIT NONE
    REAL*4, INTENT(IN) :: v1(3)
    REAL*4, INTENT(IN) :: v2(3)
    dot_xy = v1(1)*v2(1) + v1(2)*v2(2)
  END FUNCTION DOT_XY

!  Differentiation of cross_xy in reverse (adjoint) mode (with options OpenMP):
!   gradient     of useful results: v1 v2 cross_xy
!   with respect to varying inputs: v1 v2
  SUBROUTINE CROSS_XY_B(v1, v1b, v2, v2b, cross_xyb)
    IMPLICIT NONE
    REAL*4, INTENT(IN) :: v1(3)
    REAL*4 :: v1b(3)
    REAL*4, INTENT(IN) :: v2(3)
    REAL*4 :: v2b(3)
    REAL*4 :: cross_xy
    REAL*4 :: cross_xyb
    v1b(1) = v1b(1) + v2(2)*cross_xyb
    v2b(2) = v2b(2) + v1(1)*cross_xyb
    v1b(2) = v1b(2) - v2(1)*cross_xyb
    v2b(1) = v2b(1) - v1(2)*cross_xyb
  END SUBROUTINE CROSS_XY_B

  REAL*4 FUNCTION CROSS_XY(v1, v2)
    IMPLICIT NONE
    REAL*4, INTENT(IN) :: v1(3)
    REAL*4, INTENT(IN) :: v2(3)
    cross_xy = v1(1)*v2(2) - v1(2)*v2(1)
  END FUNCTION CROSS_XY

!  Differentiation of sub_xy in reverse (adjoint) mode (with options OpenMP):
!   gradient     of useful results: v1 v2 v
!   with respect to varying inputs: v1 v2 v
  SUBROUTINE SUB_XY_B(v, vb, v1, v1b, v2, v2b)
    IMPLICIT NONE
    REAL*4 :: v(3)
    REAL*4 :: vb(3)
    REAL*4, INTENT(IN) :: v1(3)
    REAL*4 :: v1b(3)
    REAL*4, INTENT(IN) :: v2(3)
    REAL*4 :: v2b(3)
    INTEGER :: k
    DO k=2,1,-1
      v1b(k) = v1b(k) + vb(k)
      v2b(k) = v2b(k) - vb(k)
      vb(k) = 0.0_4
    END DO
  END SUBROUTINE SUB_XY_B

  SUBROUTINE SUB_XY(v, v1, v2)
    IMPLICIT NONE
    REAL*4, INTENT(OUT) :: v(3)
    REAL*4, INTENT(IN) :: v1(3)
    REAL*4, INTENT(IN) :: v2(3)
    INTEGER :: k
    DO k=1,2
      v(k) = v1(k) - v2(k)
    END DO
  END SUBROUTINE SUB_XY

!  Differentiation of norm2 in reverse (adjoint) mode (with options OpenMP):
!   gradient     of useful results: v norm2
!   with respect to varying inputs: v
  SUBROUTINE NORM2_B(v, vb, norm2b)
    IMPLICIT NONE
    REAL*4, INTENT(IN) :: v(3)
    REAL*4 :: vb(3)
    REAL*4 :: norm2b
    REAL*4 :: norm2
    CALL DOT_XY_B(v, vb, v, vb, norm2b)
  END SUBROUTINE NORM2_B

  REAL*4 FUNCTION NORM2(v)
    IMPLICIT NONE
    REAL*4, INTENT(IN) :: v(3)
    norm2 = DOT_XY(v, v)
  END FUNCTION NORM2

!  Differentiation of barycentric_coordinate in reverse (adjoint) mode (with options OpenMP):
!   gradient     of useful results: w inv
!   with respect to varying inputs: w inv
  SUBROUTINE BARYCENTRIC_COORDINATE_B(w, wb, p, inv, invb)
    IMPLICIT NONE
    REAL*4 :: w(3)
    REAL*4 :: wb(3)
    REAL*4, INTENT(IN) :: p(3)
    REAL*4, INTENT(IN) :: inv(3*3)
    REAL*4 :: invb(3*3)
    INTEGER :: k
    invb(7) = invb(7) + p(1)*wb(3)
    invb(8) = invb(8) + p(2)*wb(3)
    invb(9) = invb(9) + wb(3)
    wb(3) = 0.0_4
    invb(4) = invb(4) + p(1)*wb(2)
    invb(5) = invb(5) + p(2)*wb(2)
    invb(6) = invb(6) + wb(2)
    wb(2) = 0.0_4
    invb(1) = invb(1) + p(1)*wb(1)
    invb(2) = invb(2) + p(2)*wb(1)
    invb(3) = invb(3) + wb(1)
    wb(1) = 0.0_4
  END SUBROUTINE BARYCENTRIC_COORDINATE_B

  SUBROUTINE BARYCENTRIC_COORDINATE(w, p, inv)
    IMPLICIT NONE
    REAL*4, INTENT(OUT) :: w(3)
    REAL*4, INTENT(IN) :: p(3)
    REAL*4, INTENT(IN) :: inv(3*3)
    INTEGER :: k
    w(1) = inv(1)*p(1) + inv(2)*p(2) + inv(3)
    w(2) = inv(4)*p(1) + inv(5)*p(2) + inv(6)
    w(3) = inv(7)*p(1) + inv(8)*p(2) + inv(9)
  END SUBROUTINE BARYCENTRIC_COORDINATE

  LOGICAL FUNCTION CHECK_BORDER(p, faces_t, threshold_t, fn, bn)
    IMPLICIT NONE
    REAL*4, INTENT(IN) :: p(3), faces_t(3*3*num_faces*batch_size)
    REAL*4, INTENT(IN) :: threshold_t
    INTEGER, INTENT(IN) :: fn, bn
    INTEGER :: d
    REAL*4 :: t
    INTRINSIC SQRT
    INTRINSIC MAX
    INTRINSIC MIN
    REAL*4 :: x1
    REAL*4 :: x2
    REAL*4 :: x3
    REAL*4 :: x4
    REAL*4 :: max1
    REAL*4 :: min1
    REAL*4 :: max2
    REAL*4 :: min2
    d = (bn-1)*(num_faces*3*3) + (fn-1)*(3*3) + 1
    t = SQRT(threshold_t)
    IF (faces_t(d+0) .LT. faces_t(d+3)) THEN
      x1 = faces_t(d+3)
    ELSE
      x1 = faces_t(d+0)
    END IF
    IF (x1 .LT. faces_t(d+6)) THEN
      max1 = faces_t(d+6)
    ELSE
      max1 = x1
    END IF
    IF (faces_t(d+0) .GT. faces_t(d+3)) THEN
      x2 = faces_t(d+3)
    ELSE
      x2 = faces_t(d+0)
    END IF
    IF (x2 .GT. faces_t(d+6)) THEN
      min1 = faces_t(d+6)
    ELSE
      min1 = x2
    END IF
    IF (faces_t(d+1) .LT. faces_t(d+4)) THEN
      x3 = faces_t(d+4)
    ELSE
      x3 = faces_t(d+1)
    END IF
    IF (x3 .LT. faces_t(d+7)) THEN
      max2 = faces_t(d+7)
    ELSE
      max2 = x3
    END IF
    IF (faces_t(d+1) .GT. faces_t(d+4)) THEN
      x4 = faces_t(d+4)
    ELSE
      x4 = faces_t(d+1)
    END IF
    IF (x4 .GT. faces_t(d+7)) THEN
      min2 = faces_t(d+7)
    ELSE
      min2 = x4
    END IF
    check_border = ((p(1) .GT. max1 + t .OR. p(1) .LT. min1 - t) .OR. p(&
&     2) .GT. max2 + t) .OR. p(2) .LT. min2 - t
  END FUNCTION CHECK_BORDER

  LOGICAL FUNCTION CHECK_FACE_FRONTSIDE(faces_t, fn, bn)
    IMPLICIT NONE
    REAL*4, INTENT(IN) :: faces_t(3*3*num_faces*batch_size)
    INTEGER, INTENT(IN) :: fn, bn
    INTEGER :: d
    d = (bn-1)*(num_faces*3*3) + (fn-1)*(3*3) + 1
    check_face_frontside = (faces_t(d+7)-faces_t(d+1))*(faces_t(d+3)-&
&     faces_t(d+0)) .LT. (faces_t(d+4)-faces_t(d+1))*(faces_t(d+6)-&
&     faces_t(d+0))
  END FUNCTION CHECK_FACE_FRONTSIDE

!  Differentiation of barycentric_clip in reverse (adjoint) mode (with options OpenMP):
!   gradient     of useful results: w w_clip
!   with respect to varying inputs: w w_clip
  SUBROUTINE BARYCENTRIC_CLIP_B(w_clip, w_clipb, w, wb)
    IMPLICIT NONE
    REAL*4, INTENT(IN) :: w(3)
    REAL*4 :: wb(3)
    REAL*4 :: w_clip(3)
    REAL*4 :: w_clipb(3)
    REAL*4 :: w_sum
    REAL*4 :: w_sumb
    INTEGER :: k
    INTRINSIC MIN
    INTRINSIC MAX
    REAL*4 :: x1
    REAL*4 :: x1b
    REAL*4, DIMENSION(3) :: ad_save
    REAL*4, DIMENSION(3) :: ad_save0
    INTEGER, DIMENSION(3) :: ad_branch
    INTEGER, DIMENSION(3) :: ad_branch0
    INTEGER, DIMENSION(3) :: ad_branch1
    DO k=1,3
      IF (w(k) .GT. 1.0) THEN
        ad_branch(k) = 0
        x1 = 1.0
      ELSE
        x1 = w(k)
        ad_branch(k) = 1
      END IF
      IF (x1 .LT. 0.0) THEN
        ad_save(k) = w_clip(k)
        w_clip(k) = 0.0
        ad_branch0(k) = 0
      ELSE
        ad_save0(k) = w_clip(k)
        w_clip(k) = x1
        ad_branch0(k) = 1
      END IF
    END DO
    IF (w_clip(1) + w_clip(2) + w_clip(3) .LT. 1e-5) THEN
      ad_branch1(k) = 0
      w_sum = 1e-5
    ELSE
      w_sum = w_clip(1) + w_clip(2) + w_clip(3)
      ad_branch1(k) = 1
    END IF
    w_sumb = 0.0_4
    DO k=3,1,-1
      w_sumb = w_sumb - w_clip(k)*w_clipb(k)/w_sum**2
      w_clipb(k) = w_clipb(k)/w_sum
    END DO
    IF (ad_branch1(k) .NE. 0) THEN
      w_clipb(1) = w_clipb(1) + w_sumb
      w_clipb(2) = w_clipb(2) + w_sumb
      w_clipb(3) = w_clipb(3) + w_sumb
    END IF
    DO k=3,1,-1
      IF (ad_branch0(k) .EQ. 0) THEN
        w_clip(k) = ad_save(k)
        w_clipb(k) = 0.0_4
        x1b = 0.0_4
      ELSE
        w_clip(k) = ad_save0(k)
        x1b = w_clipb(k)
        w_clipb(k) = 0.0_4
      END IF
      IF (ad_branch(k) .NE. 0) wb(k) = wb(k) + x1b
    END DO
  END SUBROUTINE BARYCENTRIC_CLIP_B

  SUBROUTINE BARYCENTRIC_CLIP(w_clip, w)
    IMPLICIT NONE
    REAL*4, INTENT(IN) :: w(3)
    REAL*4, INTENT(OUT) :: w_clip(3)
    REAL*4 :: w_sum
    INTEGER :: k
    INTRINSIC MIN
    INTRINSIC MAX
    REAL*4 :: x1
    DO k=1,3
      IF (w(k) .GT. 1.0) THEN
        x1 = 1.0
      ELSE
        x1 = w(k)
      END IF
      IF (x1 .LT. 0.0) THEN
        w_clip(k) = 0.0
      ELSE
        w_clip(k) = x1
      END IF
    END DO
    IF (w_clip(1) + w_clip(2) + w_clip(3) .LT. 1e-5) THEN
      w_sum = 1e-5
    ELSE
      w_sum = w_clip(1) + w_clip(2) + w_clip(3)
    END IF
    DO k=1,3
      w_clip(k) = w_clip(k)/w_sum
    END DO
  END SUBROUTINE BARYCENTRIC_CLIP

!  Differentiation of euclidean_p2f_distance in reverse (adjoint) mode (with options OpenMP):
!   gradient     of useful results: faces_t euclidean_p2f_distance
!   with respect to varying inputs: faces_t
  SUBROUTINE EUCLIDEAN_P2F_DISTANCE_B(faces_t, faces_tb, p, fn, bn, &
&   euclidean_p2f_distanceb)
    IMPLICIT NONE
    REAL*4, INTENT(IN) :: faces_t(3*3*num_faces*batch_size), p(3)
    REAL*4 :: faces_tb(3*3*num_faces*batch_size)
    INTEGER, INTENT(IN) :: fn, bn
    REAL*4 :: dis(3)
    REAL*4 :: disb(3)
    REAL*4, DIMENSION(3) :: tmp0, tmp1, t1, t2, t3
    REAL*4, DIMENSION(3) :: tmp0b, tmp1b, t1b, t2b, t3b
    REAL*4 :: area, d1, d2, len
    REAL*4 :: areab, lenb
    INTEGER :: k, l
    INTEGER :: d
    INTRINSIC MOD
    INTRINSIC MAX
    INTRINSIC MIN
    REAL*4 :: x1
    REAL*4 :: x1b
    REAL*4 :: max1
    REAL*4 :: max1b
    REAL*4, DIMENSION(3, 3) :: ad_save
    REAL*4, DIMENSION(3) :: pb
    REAL*4, DIMENSION(3, 3) :: ad_save0
    REAL*4, DIMENSION(3) :: ad_save1
    REAL*4, DIMENSION(3, 3) :: ad_save2
    REAL*4, DIMENSION(3) :: ad_save3
    REAL*4, DIMENSION(3) :: ad_save4
    INTEGER, DIMENSION(3) :: ad_branch
    INTEGER, DIMENSION(3) :: ad_branch0
    INTEGER :: ad_branch1
    REAL*4 :: euclidean_p2f_distanceb
    REAL*4 :: euclidean_p2f_distance
    d = (bn-1)*(num_faces*3*3) + (fn-1)*(3*3) + 1
    DO k=1,3
      tmp0(1) = faces_t(d+(k-1)*3+0)
      tmp0(2) = faces_t(d+(k-1)*3+1)
      tmp0(3) = faces_t(d+(k-1)*3+2)
      tmp1(1) = faces_t(d+MOD(k, 3)*3+0)
      tmp1(2) = faces_t(d+MOD(k, 3)*3+1)
      tmp1(3) = faces_t(d+MOD(k, 3)*3+2)
      ad_save(:, k) = t1
      CALL SUB_XY(t1, p, tmp0)
      ad_save0(:, k) = t2
      CALL SUB_XY(t2, tmp1, tmp0)
      ad_save1(k) = area
      area = CROSS_XY(t1, t2)
      d1 = DOT_XY(t1, t2)
      IF (d1 .GE. 0.0) THEN
        ad_save2(:, k) = t3
        CALL SUB_XY(t3, tmp1, p)
        d2 = DOT_XY(t2, t3)
        IF (d2 .GE. 0.0) THEN
          len = NORM2(t2)
          IF (len .LT. 1e-10) THEN
            ad_save3(k) = max1
            max1 = 1e-10
            ad_branch(k) = 0
          ELSE
            ad_save4(k) = max1
            max1 = len
            ad_branch(k) = 1
          END IF
          dis(k) = area/max1*area
          ad_branch0(k) = 2
        ELSE
          dis(k) = NORM2(t3)
          ad_branch0(k) = 1
        END IF
      ELSE
        dis(k) = NORM2(t1)
        ad_branch0(k) = 0
      END IF
    END DO
    IF (dis(1) .GT. dis(2)) THEN
      x1 = dis(2)
      ad_branch1 = 0
    ELSE
      x1 = dis(1)
      ad_branch1 = 1
    END IF
    IF (x1 .GT. dis(3)) THEN
      disb = 0.0_4
      disb(3) = disb(3) + euclidean_p2f_distanceb
      x1b = 0.0_4
    ELSE
      x1b = euclidean_p2f_distanceb
      disb = 0.0_4
    END IF
    IF (ad_branch1 .EQ. 0) THEN
      disb(2) = disb(2) + x1b
    ELSE
      disb(1) = disb(1) + x1b
    END IF
    tmp0b = 0.0_4
    tmp1b = 0.0_4
    t1b = 0.0_4
    t2b = 0.0_4
    t3b = 0.0_4
    DO k=3,1,-1
      IF (ad_branch0(k) .EQ. 0) THEN
        CALL NORM2_B(t1, t1b, disb(k))
        disb(k) = 0.0_4
        areab = 0.0_4
      ELSE
        IF (ad_branch0(k) .EQ. 1) THEN
          CALL NORM2_B(t3, t3b, disb(k))
          disb(k) = 0.0_4
          areab = 0.0_4
        ELSE
          areab = 2*area*disb(k)/max1
          max1b = -(area**2*disb(k)/max1**2)
          disb(k) = 0.0_4
          IF (ad_branch(k) .EQ. 0) THEN
            max1 = ad_save3(k)
            lenb = 0.0_4
          ELSE
            max1 = ad_save4(k)
            lenb = max1b
          END IF
          CALL NORM2_B(t2, t2b, lenb)
        END IF
        t3 = ad_save2(:, k)
        pb = 0.0_4
        CALL SUB_XY_B(t3, t3b, tmp1, tmp1b, p, pb)
      END IF
      area = ad_save1(k)
      CALL CROSS_XY_B(t1, t1b, t2, t2b, areab)
      t2 = ad_save0(:, k)
      CALL SUB_XY_B(t2, t2b, tmp1, tmp1b, tmp0, tmp0b)
      t1 = ad_save(:, k)
      pb = 0.0_4
      CALL SUB_XY_B(t1, t1b, p, pb, tmp0, tmp0b)
!$OMP ATOMIC update
      faces_tb(d+MOD(k, 3)*3+2) = faces_tb(d+MOD(k, 3)*3+2) + tmp1b(3)
      tmp1b(3) = 0.0_4
!$OMP ATOMIC update
      faces_tb(d+MOD(k, 3)*3+1) = faces_tb(d+MOD(k, 3)*3+1) + tmp1b(2)
      tmp1b(2) = 0.0_4
!$OMP ATOMIC update
      faces_tb(d+MOD(k, 3)*3+0) = faces_tb(d+MOD(k, 3)*3+0) + tmp1b(1)
      tmp1b(1) = 0.0_4
!$OMP ATOMIC update
      faces_tb(d+(k-1)*3+2) = faces_tb(d+(k-1)*3+2) + tmp0b(3)
      tmp0b(3) = 0.0_4
!$OMP ATOMIC update
      faces_tb(d+(k-1)*3+1) = faces_tb(d+(k-1)*3+1) + tmp0b(2)
      tmp0b(2) = 0.0_4
!$OMP ATOMIC update
      faces_tb(d+(k-1)*3+0) = faces_tb(d+(k-1)*3+0) + tmp0b(1)
      tmp0b(1) = 0.0_4
    END DO
  END SUBROUTINE EUCLIDEAN_P2F_DISTANCE_B

  REAL*4 FUNCTION EUCLIDEAN_P2F_DISTANCE(faces_t, p, fn, bn)
    IMPLICIT NONE
    REAL*4, INTENT(IN) :: faces_t(3*3*num_faces*batch_size), p(3)
    INTEGER, INTENT(IN) :: fn, bn
    REAL*4 :: dis(3)
    REAL*4, DIMENSION(3) :: tmp0, tmp1, t1, t2, t3
    REAL*4 :: area, d1, d2, len
    INTEGER :: k, l
    INTEGER :: d
    INTRINSIC MOD
    INTRINSIC MAX
    INTRINSIC MIN
    REAL*4 :: x1
    REAL*4 :: max1
    d = (bn-1)*(num_faces*3*3) + (fn-1)*(3*3) + 1
    DO k=1,3
      tmp0(1) = faces_t(d+(k-1)*3+0)
      tmp0(2) = faces_t(d+(k-1)*3+1)
      tmp0(3) = faces_t(d+(k-1)*3+2)
      tmp1(1) = faces_t(d+MOD(k, 3)*3+0)
      tmp1(2) = faces_t(d+MOD(k, 3)*3+1)
      tmp1(3) = faces_t(d+MOD(k, 3)*3+2)
      CALL SUB_XY(t1, p, tmp0)
      CALL SUB_XY(t2, tmp1, tmp0)
      area = CROSS_XY(t1, t2)
      d1 = DOT_XY(t1, t2)
      IF (d1 .GE. 0.0) THEN
        CALL SUB_XY(t3, tmp1, p)
        d2 = DOT_XY(t2, t3)
        IF (d2 .GE. 0.0) THEN
          len = NORM2(t2)
          IF (len .LT. 1e-10) THEN
            max1 = 1e-10
          ELSE
            max1 = len
          END IF
          dis(k) = area/max1*area
        ELSE
          dis(k) = NORM2(t3)
        END IF
      ELSE
        dis(k) = NORM2(t1)
      END IF
    END DO
    IF (dis(1) .GT. dis(2)) THEN
      x1 = dis(2)
    ELSE
      x1 = dis(1)
    END IF
    IF (x1 .GT. dis(3)) THEN
      euclidean_p2f_distance = dis(3)
    ELSE
      euclidean_p2f_distance = x1
    END IF
  END FUNCTION EUCLIDEAN_P2F_DISTANCE

!  Differentiation of forward_sample_texture in reverse (adjoint) mode (with options OpenMP):
!   gradient     of useful results: forward_sample_texture textures_t
!   with respect to varying inputs: textures_t
  SUBROUTINE FORWARD_SAMPLE_TEXTURE_B(textures_t, textures_tb, w, r, k, &
&   ty, fn, bn, forward_sample_textureb)
    IMPLICIT NONE
    REAL*4, INTENT(IN) :: textures_t(3*texture_size*num_faces*batch_size&
&   ), w(3)
    REAL*4 :: textures_tb(3*texture_size*num_faces*batch_size)
    INTEGER, INTENT(IN) :: r, k, ty, fn, bn
    INTEGER :: w_x, w_y
    INTEGER :: d
    REAL*4 :: texture_k
    REAL*4 :: texture_kb
    INTRINSIC INT
    INTEGER :: ad_branch
    REAL*4 :: forward_sample_texture
    REAL*4 :: forward_sample_textureb
    d = (bn-1)*(num_faces*texture_size*3) + (fn-1)*(texture_size*3)
    IF (ty .EQ. 0) THEN
      w_x = INT(w(1)*r)
      w_y = INT(w(2)*r)
      IF ((w(1)+w(2))*r - w_x - w_y .LE. 1) THEN
        IF (w_y*r + w_x .EQ. texture_size) THEN
          ad_branch = 0
        ELSE
          ad_branch = 1
        END IF
      ELSE
        ad_branch = 2
      END IF
    ELSE
      ad_branch = 3
    END IF
    texture_kb = forward_sample_textureb
    IF (ad_branch .LT. 2) THEN
      IF (ad_branch .EQ. 0) THEN
!$OMP   ATOMIC update
        textures_tb(d+(w_y*r+w_x-1)*3+k) = textures_tb(d+(w_y*r+w_x-1)*3&
&         +k) + texture_kb
      ELSE
!$OMP   ATOMIC update
        textures_tb(d+(w_y*r+w_x)*3+k) = textures_tb(d+(w_y*r+w_x)*3+k) &
&         + texture_kb
      END IF
    ELSE IF (ad_branch .EQ. 2) THEN
!$OMP ATOMIC update
      textures_tb(d+((r-1-w_y)*r+(r-1-w_x))*3+k) = textures_tb(d+((r-1-&
&       w_y)*r+(r-1-w_x))*3+k) + texture_kb
    END IF
  END SUBROUTINE FORWARD_SAMPLE_TEXTURE_B

  REAL*4 FUNCTION FORWARD_SAMPLE_TEXTURE(textures_t, w, r, k, ty, fn, bn&
& )
    IMPLICIT NONE
    REAL*4, INTENT(IN) :: textures_t(3*texture_size*num_faces*batch_size&
&   ), w(3)
    INTEGER, INTENT(IN) :: r, k, ty, fn, bn
    INTEGER :: w_x, w_y
    INTEGER :: d
    REAL*4 :: texture_k
    INTRINSIC INT
    d = (bn-1)*(num_faces*texture_size*3) + (fn-1)*(texture_size*3)
    IF (ty .EQ. 0) THEN
      w_x = INT(w(1)*r)
      w_y = INT(w(2)*r)
      IF ((w(1)+w(2))*r - w_x - w_y .LE. 1) THEN
        IF (w_y*r + w_x .EQ. texture_size) THEN
          texture_k = textures_t(d+(w_y*r+w_x-1)*3+k)
        ELSE
          texture_k = textures_t(d+(w_y*r+w_x)*3+k)
        END IF
      ELSE
        texture_k = textures_t(d+((r-1-w_y)*r+(r-1-w_x))*3+k)
      END IF
    END IF
    forward_sample_texture = texture_k
  END FUNCTION FORWARD_SAMPLE_TEXTURE

!  Differentiation of tapenade_render_main in reverse (adjoint) mode (with options OpenMP):
!   gradient     of useful results: soft_colors_t
!   with respect to varying inputs: faces_t soft_colors_t textures_t
!   RW status of diff variables: faces_t:out soft_colors_t:in-out
!                textures_t:out
  SUBROUTINE TAPENADE_RENDER_MAIN_B(soft_colors_t, soft_colors_tb, &
&   faces_t, faces_tb, textures_t, textures_tb) BIND(c)
    IMPLICIT NONE
    REAL*4, INTENT(INOUT) :: soft_colors_t(image_size*image_size*4*&
&   batch_size)
    REAL*4, INTENT(INOUT) :: soft_colors_tb(image_size*image_size*4*&
&   batch_size)
    REAL*4, INTENT(IN) :: faces_t(3*3*num_faces*batch_size)
    REAL*4 :: faces_tb(3*3*num_faces*batch_size)
    REAL*4, INTENT(IN) :: textures_t(3*texture_size*num_faces*batch_size&
&   )
    REAL*4 :: textures_tb(3*texture_size*num_faces*batch_size)
    INTEGER :: bn, pn, yi, xi, fn, k, d
    REAL*4, DIMENSION(3) :: pixel
    REAL*4, DIMENSION(3*3) :: inv
    REAL*4, DIMENSION(3*3) :: invb
    REAL*4, DIMENSION(3) :: w, w_clip
    REAL*4, DIMENSION(3) :: wb, w_clipb
    REAL*4, DIMENSION(3) :: soft_color
    REAL*4, DIMENSION(3) :: soft_colorb
    REAL*4, DIMENSION(num_faces) :: soft_color_alpha
    REAL*4, DIMENSION(num_faces) :: soft_color_alphab
    REAL*4 :: sign, softmax_max, softmax_sum, zp, zp_norm, coef, color_k&
&   , soft_fragment, dis
    REAL*4 :: softmax_maxb, softmax_sumb, zpb, zp_normb, coefb, color_kb&
&   , soft_fragmentb, disb
    INTRINSIC INT
    INTRINSIC MOD
    INTRINSIC EXP
    LOGICAL :: result1
    REAL*4 :: temp
    REAL*4 :: temp0
    REAL*4 :: temp1
    REAL*4 :: temp2
    REAL*4 :: tempb
    REAL*4 :: tempb0
    REAL*4 :: tempb1
    REAL*4 :: tempb2
    INTEGER*4 :: branch
    INTEGER :: chunk_start
    INTEGER :: chunk_end
    INTEGER :: ichunk
    INTEGER :: numchunks
    DO bn=1,batch_size
!$OMP PARALLEL SHARED(image_size, batch_size, num_faces, texture_size, &
!$OMP&soft_colors_t, faces_t, textures_t, bn, texture_res, near, far, &
!$OMP&eps, sigma_val, gamma_val, dist_eps, threshold, double_side, &
!$OMP&texture_type), PRIVATE(pn, yi, xi, fn, k, d, pixel, inv, w, w_clip&
!$OMP&, soft_color, soft_color_alpha, sign, softmax_max, softmax_sum, zp&
!$OMP&, zp_norm, coef, color_k, soft_fragment, dis), PRIVATE(result1)
      CALL INITDYNAMICSCHEDULE()
!$OMP DO 
      DO pn=1,image_size*image_size
        CALL RECORDDYNAMICSCHEDULE(pn, 1)
        yi = image_size - 1 - INT((pn-1)/image_size)
        xi = MOD(pn - 1, image_size)
        CALL PUSHREAL4(pixel(1))
        pixel(1) = (2.0*xi+1.0-image_size)/image_size
        CALL PUSHREAL4(pixel(2))
        pixel(2) = (2.0*yi+1.0-image_size)/image_size
        CALL PUSHREAL4(softmax_max)
        softmax_max = eps
        CALL PUSHREAL4(soft_color_alpha(1))
        soft_color_alpha(1) = 1.0
        DO fn=1,num_faces
          d = (bn-1)*(num_faces*3*3) + (fn-1)*(3*3) + 1
          CALL FACE_INV(inv, faces_t, fn, bn)
          result1 = CHECK_BORDER(pixel, faces_t, threshold, fn, bn)
          IF (.NOT.result1) THEN
            CALL PUSHREAL4ARRAY(w, 3)
            CALL BARYCENTRIC_COORDINATE(w, pixel, inv)
            CALL PUSHREAL4ARRAY(w_clip, 3)
            CALL BARYCENTRIC_CLIP(w_clip, w)
            zp = 1.0/(w_clip(1)/faces_t(d+2)+w_clip(2)/faces_t(d+5)+&
&             w_clip(3)/faces_t(d+8))
            IF (.NOT.(zp .LT. near .OR. zp .GT. far)) THEN
              result1 = CHECK_FACE_FRONTSIDE(faces_t, fn, bn)
              IF (result1 .OR. double_side) THEN
                CALL PUSHREAL4(zp_norm)
                zp_norm = (far-zp)/(far-near)
                IF (zp_norm .GT. softmax_max) THEN
                  softmax_max = zp_norm
                  CALL PUSHCONTROL3B(4)
                ELSE
                  CALL PUSHCONTROL3B(3)
                END IF
              ELSE
                CALL PUSHCONTROL3B(2)
              END IF
            ELSE
              CALL PUSHCONTROL3B(1)
            END IF
          ELSE
            CALL PUSHCONTROL3B(0)
          END IF
        END DO
        CALL PUSHREAL4(softmax_sum)
        softmax_sum = EXP((2*eps-softmax_max)/gamma_val)
        DO k=1,3
          CALL PUSHREAL4(soft_color(k))
          soft_color(k) = soft_colors_t((bn-1)*(4*image_size*image_size)&
&           +(k-1)*(image_size*image_size)+pn)*softmax_sum
        END DO
        DO fn=1,num_faces
          d = (bn-1)*(num_faces*3*3) + (fn-1)*(3*3) + 1
          IF (fn .GT. 1) THEN
            CALL PUSHREAL4(soft_color_alpha(fn))
            soft_color_alpha(fn) = soft_color_alpha(fn-1)
            CALL PUSHCONTROL1B(0)
          ELSE
            CALL PUSHCONTROL1B(1)
          END IF
          CALL FACE_INV(inv, faces_t, fn, bn)
          result1 = CHECK_BORDER(pixel, faces_t, threshold, fn, bn)
          IF (.NOT.result1) THEN
            CALL PUSHREAL4ARRAY(w, 3)
            CALL BARYCENTRIC_COORDINATE(w, pixel, inv)
            IF (w(1) .GT. 0 .AND. w(2) .GT. 0 .AND. w(3) .GT. 0 .AND. w(&
&               1) .LT. 1 .AND. w(2) .LT. 1 .AND. w(3) .LT. 1) THEN
              CALL PUSHREAL4(sign)
              sign = 1.0
              CALL PUSHCONTROL1B(0)
            ELSE
              CALL PUSHREAL4(sign)
              sign = -1.0
              CALL PUSHCONTROL1B(1)
            END IF
            CALL PUSHREAL4(dis)
            dis = EUCLIDEAN_P2F_DISTANCE(faces_t, pixel, fn, bn)
            IF (.NOT.(sign .LT. 0.0 .AND. dis .GE. threshold)) THEN
              CALL PUSHREAL4(soft_fragment)
              soft_fragment = 1.0/(1.0+EXP(-(sign*dis/sigma_val)))
              IF (fn .GT. 1) THEN
                CALL PUSHREAL4(soft_color_alpha(fn))
                soft_color_alpha(fn) = soft_color_alpha(fn-1)*(1.0-&
&                 soft_fragment)
                CALL PUSHCONTROL1B(0)
              ELSE
                CALL PUSHREAL4(soft_color_alpha(fn))
                soft_color_alpha(fn) = 1.0 - soft_fragment
                CALL PUSHCONTROL1B(1)
              END IF
              CALL PUSHREAL4ARRAY(w_clip, 3)
              CALL BARYCENTRIC_CLIP(w_clip, w)
              zp = 1.0/(w_clip(1)/faces_t(d+2)+w_clip(2)/faces_t(d+5)+&
&               w_clip(3)/faces_t(d+8))
              IF (.NOT.(zp .LT. near .OR. zp .GT. far)) THEN
                result1 = CHECK_FACE_FRONTSIDE(faces_t, fn, bn)
                IF (result1 .OR. double_side) THEN
                  CALL PUSHREAL4(zp_norm)
                  zp_norm = (far-zp)/(far-near)
                  CALL PUSHREAL4(coef)
                  coef = EXP((zp_norm-softmax_max)/gamma_val)*&
&                   soft_fragment
                  CALL PUSHREAL4(softmax_sum)
                  softmax_sum = softmax_sum + coef
                  DO k=1,3
                    CALL PUSHREAL4(color_k)
                    color_k = FORWARD_SAMPLE_TEXTURE(textures_t, w_clip&
&                     , texture_res, k, texture_type, fn, bn)
                    soft_color(k) = soft_color(k) + coef*color_k
                  END DO
                  CALL PUSHCONTROL3B(4)
                ELSE
                  CALL PUSHCONTROL3B(3)
                END IF
              ELSE
                CALL PUSHCONTROL3B(2)
              END IF
            ELSE
              CALL PUSHCONTROL3B(1)
            END IF
          ELSE
            CALL PUSHCONTROL3B(0)
          END IF
        END DO
        CALL PUSHREAL4(soft_colors_t((bn-1)*(4*image_size*image_size)+(4&
&                -1)*(image_size*image_size)+pn))
        soft_colors_t((bn-1)*(4*image_size*image_size)+(4-1)*(image_size&
&       *image_size)+pn) = 1.0 - soft_color_alpha(num_faces)
        DO k=1,3
          CALL PUSHREAL4(soft_colors_t((bn-1)*(4*image_size*image_size)+&
&                  (k-1)*(image_size*image_size)+pn))
          soft_colors_t((bn-1)*(4*image_size*image_size)+(k-1)*(&
&         image_size*image_size)+pn) = soft_color(k)/softmax_sum
        END DO
      END DO
      CALL FINALIZEDYNAMICSCHEDULE()
      CALL PUSHREAL4(softmax_sum)
      CALL PUSHREAL4(sign)
      CALL PUSHREAL4(dis)
      CALL PUSHREAL4ARRAY(pixel, 3)
      CALL PUSHREAL4(color_k)
      CALL PUSHREAL4(soft_fragment)
      CALL PUSHREAL4ARRAY(w_clip, 3)
      CALL PUSHREAL4ARRAY(soft_color, 3)
      CALL PUSHREAL4ARRAY(w, 3)
      CALL PUSHREAL4(zp_norm)
      CALL PUSHREAL4ARRAY(soft_color_alpha, num_faces)
      CALL PUSHREAL4(coef)
      CALL PUSHREAL4(softmax_max)
!$OMP END PARALLEL
    END DO
    faces_tb = 0.0_4
    textures_tb = 0.0_4
    soft_color_alphab = 0.0_4
    wb = 0.0_4
    soft_colorb = 0.0_4
    w_clipb = 0.0_4
    invb = 0.0_4
    DO bn=batch_size,1,-1
!$OMP PARALLEL SHARED(image_size, batch_size, num_faces, texture_size, &
!$OMP&soft_colors_t, faces_t, textures_t, bn, texture_res, near, far, &
!$OMP&eps, sigma_val, gamma_val, dist_eps, threshold, double_side, &
!$OMP&texture_type), SHARED(soft_colors_tb, faces_tb, textures_tb), &
!$OMP&PRIVATE(pn, yi, xi, fn, k, d, pixel, inv, w, w_clip, soft_color, &
!$OMP&soft_color_alpha, sign, softmax_max, softmax_sum, zp, zp_norm, &
!$OMP&coef, color_k, soft_fragment, dis), PRIVATE(invb, wb, w_clipb, &
!$OMP&soft_colorb, soft_color_alphab, softmax_maxb, softmax_sumb, zpb, &
!$OMP&zp_normb, coefb, color_kb, soft_fragmentb, disb), PRIVATE(result1&
!$OMP&, temp, temp0, temp1, temp2, branch, numchunks, ichunk, chunk_end&
!$OMP&, chunk_start)
      CALL POPREAL4(softmax_max)
      CALL POPREAL4(coef)
      CALL POPREAL4ARRAY(soft_color_alpha, num_faces)
      CALL POPREAL4(zp_norm)
      CALL POPREAL4ARRAY(w, 3)
      CALL POPREAL4ARRAY(soft_color, 3)
      CALL POPREAL4ARRAY(w_clip, 3)
      CALL POPREAL4(soft_fragment)
      CALL POPREAL4(color_k)
      CALL POPREAL4ARRAY(pixel, 3)
      CALL POPREAL4(dis)
      CALL POPREAL4(sign)
      CALL POPREAL4(softmax_sum)
      invb = 0.0_4
      wb = 0.0_4
      w_clipb = 0.0_4
      soft_colorb = 0.0_4
      soft_color_alphab = 0.0_4
      softmax_maxb = 0.0_4
      softmax_sumb = 0.0_4
      zpb = 0.0_4
      zp_normb = 0.0_4
      coefb = 0.0_4
      color_kb = 0.0_4
      soft_fragmentb = 0.0_4
      disb = 0.0_4
      CALL POPINTEGER4(numchunks)
      DO ichunk=1,numchunks
        CALL POPINTEGER4(chunk_end)
        CALL POPINTEGER4(chunk_start)
        DO pn=chunk_end,chunk_start,-1
          softmax_sumb = 0.0_4
          DO k=3,1,-1
            CALL POPREAL4(soft_colors_t((bn-1)*(4*image_size*image_size)&
&                   +(k-1)*(image_size*image_size)+pn))
            soft_colorb(k) = soft_colorb(k) + soft_colors_tb((bn-1)*(4*&
&             image_size*image_size)+(k-1)*(image_size*image_size)+pn)/&
&             softmax_sum
            softmax_sumb = softmax_sumb - soft_color(k)*soft_colors_tb((&
&             bn-1)*(4*image_size*image_size)+(k-1)*(image_size*&
&             image_size)+pn)/softmax_sum**2
            soft_colors_tb((bn-1)*(4*image_size*image_size)+(k-1)*(&
&           image_size*image_size)+pn) = 0.0_4
          END DO
          CALL POPREAL4(soft_colors_t((bn-1)*(4*image_size*image_size)+(&
&                 4-1)*(image_size*image_size)+pn))
          soft_color_alphab(num_faces) = soft_color_alphab(num_faces) - &
&           soft_colors_tb((bn-1)*(4*image_size*image_size)+(4-1)*(&
&           image_size*image_size)+pn)
          soft_colors_tb((bn-1)*(4*image_size*image_size)+(4-1)*(&
&         image_size*image_size)+pn) = 0.0_4
          softmax_maxb = 0.0_4
          DO fn=num_faces,1,-1
            CALL POPCONTROL3B(branch)
            IF (branch .LT. 2) THEN
              IF (branch .EQ. 0) THEN
                GOTO 100
              ELSE
                disb = 0.0_4
              END IF
            ELSE
              IF (branch .EQ. 2) THEN
                soft_fragmentb = 0.0_4
                zpb = 0.0_4
              ELSE IF (branch .EQ. 3) THEN
                soft_fragmentb = 0.0_4
                zpb = 0.0_4
              ELSE
                coefb = 0.0_4
                DO k=3,1,-1
                  coefb = coefb + color_k*soft_colorb(k)
                  color_kb = coef*soft_colorb(k)
                  CALL POPREAL4(color_k)
                  CALL FORWARD_SAMPLE_TEXTURE_B(textures_t, textures_tb&
&                                         , w_clip, texture_res, k, &
&                                         texture_type, fn, bn, color_kb&
&                                        )
                END DO
                CALL POPREAL4(softmax_sum)
                coefb = coefb + softmax_sumb
                CALL POPREAL4(coef)
                temp2 = (zp_norm-softmax_max)/gamma_val
                tempb = EXP(temp2)*soft_fragment*coefb/gamma_val
                soft_fragmentb = EXP(temp2)*coefb
                zp_normb = tempb
                softmax_maxb = softmax_maxb - tempb
                CALL POPREAL4(zp_norm)
                zpb = -(zp_normb/(far-near))
              END IF
              d = (bn-1)*(num_faces*3*3) + (fn-1)*(3*3) + 1
              temp2 = w_clip(3)/faces_t(d+8)
              temp1 = w_clip(2)/faces_t(d+5)
              temp0 = w_clip(1)/faces_t(d+2)
              temp = temp0 + temp1 + temp2
              tempb2 = -(zpb/temp**2)
              tempb1 = tempb2/faces_t(d+2)
              tempb0 = tempb2/faces_t(d+5)
              tempb = tempb2/faces_t(d+8)
              w_clipb(3) = w_clipb(3) + tempb
!$OMP         ATOMIC update
              faces_tb(d+8) = faces_tb(d+8) - temp2*tempb
              w_clipb(2) = w_clipb(2) + tempb0
!$OMP         ATOMIC update
              faces_tb(d+5) = faces_tb(d+5) - temp1*tempb0
              w_clipb(1) = w_clipb(1) + tempb1
!$OMP         ATOMIC update
              faces_tb(d+2) = faces_tb(d+2) - temp0*tempb1
              CALL POPREAL4ARRAY(w_clip, 3)
              CALL BARYCENTRIC_CLIP_B(w_clip, w_clipb, w, wb)
              CALL POPCONTROL1B(branch)
              IF (branch .EQ. 0) THEN
                CALL POPREAL4(soft_color_alpha(fn))
                soft_color_alphab(fn-1) = soft_color_alphab(fn-1) + (1.0&
&                 -soft_fragment)*soft_color_alphab(fn)
                soft_fragmentb = soft_fragmentb - soft_color_alpha(fn-1)&
&                 *soft_color_alphab(fn)
                soft_color_alphab(fn) = 0.0_4
              ELSE
                CALL POPREAL4(soft_color_alpha(fn))
                soft_fragmentb = soft_fragmentb - soft_color_alphab(fn)
                soft_color_alphab(fn) = 0.0_4
              END IF
              CALL POPREAL4(soft_fragment)
              temp2 = -(sign*dis/sigma_val)
              temp1 = EXP(temp2) + 1.0
              disb = sign*EXP(temp2)*soft_fragmentb/(sigma_val*temp1**2)
            END IF
            CALL POPREAL4(dis)
            CALL EUCLIDEAN_P2F_DISTANCE_B(faces_t, faces_tb, pixel, fn, &
&                                   bn, disb)
            CALL POPCONTROL1B(branch)
            IF (branch .EQ. 0) THEN
              CALL POPREAL4(sign)
            ELSE
              CALL POPREAL4(sign)
            END IF
            CALL POPREAL4ARRAY(w, 3)
            CALL BARYCENTRIC_COORDINATE_B(w, wb, pixel, inv, invb)
 100        CALL FACE_INV_B(inv, invb, faces_t, faces_tb, fn, bn)
            CALL POPCONTROL1B(branch)
            IF (branch .EQ. 0) THEN
              CALL POPREAL4(soft_color_alpha(fn))
              soft_color_alphab(fn-1) = soft_color_alphab(fn-1) + &
&               soft_color_alphab(fn)
              soft_color_alphab(fn) = 0.0_4
            END IF
          END DO
          DO k=3,1,-1
            CALL POPREAL4(soft_color(k))
!$OMP       ATOMIC update
            soft_colors_tb((bn-1)*(4*image_size*image_size)+(k-1)*(&
&           image_size*image_size)+pn) = soft_colors_tb((bn-1)*(4*&
&             image_size*image_size)+(k-1)*(image_size*image_size)+pn) +&
&             softmax_sum*soft_colorb(k)
            softmax_sumb = softmax_sumb + soft_colors_t((bn-1)*(4*&
&             image_size*image_size)+(k-1)*(image_size*image_size)+pn)*&
&             soft_colorb(k)
            soft_colorb(k) = 0.0_4
          END DO
          CALL POPREAL4(softmax_sum)
          softmax_maxb = softmax_maxb - EXP((2*eps-softmax_max)/&
&           gamma_val)*softmax_sumb/gamma_val
          DO fn=num_faces,1,-1
            CALL POPCONTROL3B(branch)
            IF (branch .LT. 2) THEN
              IF (branch .EQ. 0) THEN
                GOTO 110
              ELSE
                zpb = 0.0_4
              END IF
            ELSE IF (branch .EQ. 2) THEN
              zpb = 0.0_4
            ELSE
              IF (branch .EQ. 3) THEN
                zp_normb = 0.0_4
              ELSE
                zp_normb = softmax_maxb
                softmax_maxb = 0.0_4
              END IF
              CALL POPREAL4(zp_norm)
              zpb = -(zp_normb/(far-near))
            END IF
            d = (bn-1)*(num_faces*3*3) + (fn-1)*(3*3) + 1
            temp = w_clip(3)/faces_t(d+8)
            temp0 = w_clip(2)/faces_t(d+5)
            temp1 = w_clip(1)/faces_t(d+2)
            temp2 = temp1 + temp0 + temp
            tempb = -(zpb/temp2**2)
            tempb0 = tempb/faces_t(d+2)
            tempb1 = tempb/faces_t(d+5)
            tempb2 = tempb/faces_t(d+8)
            w_clipb(3) = w_clipb(3) + tempb2
!$OMP       ATOMIC update
            faces_tb(d+8) = faces_tb(d+8) - temp*tempb2
            w_clipb(2) = w_clipb(2) + tempb1
!$OMP       ATOMIC update
            faces_tb(d+5) = faces_tb(d+5) - temp0*tempb1
            w_clipb(1) = w_clipb(1) + tempb0
!$OMP       ATOMIC update
            faces_tb(d+2) = faces_tb(d+2) - temp1*tempb0
            CALL POPREAL4ARRAY(w_clip, 3)
            CALL BARYCENTRIC_CLIP_B(w_clip, w_clipb, w, wb)
            CALL POPREAL4ARRAY(w, 3)
            CALL BARYCENTRIC_COORDINATE_B(w, wb, pixel, inv, invb)
 110        CALL FACE_INV_B(inv, invb, faces_t, faces_tb, fn, bn)
          END DO
          CALL POPREAL4(soft_color_alpha(1))
          soft_color_alphab(1) = 0.0_4
          DO k=3,1,-1
            soft_colorb(k) = 0.0_4
          END DO
          CALL POPREAL4(softmax_max)
          CALL POPREAL4(pixel(2))
          CALL POPREAL4(pixel(1))
        END DO
      END DO
!$OMP END PARALLEL
    END DO
  END SUBROUTINE TAPENADE_RENDER_MAIN_B

  SUBROUTINE TAPENADE_RENDER_MAIN(soft_colors_t, faces_t, textures_t) &
& BIND(c)
    IMPLICIT NONE
    REAL*4, INTENT(INOUT) :: soft_colors_t(image_size*image_size*4*&
&   batch_size)
    REAL*4, INTENT(IN) :: faces_t(3*3*num_faces*batch_size)
    REAL*4, INTENT(IN) :: textures_t(3*texture_size*num_faces*batch_size&
&   )
    INTEGER :: bn, pn, yi, xi, fn, k, d
    REAL*4, DIMENSION(3) :: pixel
    REAL*4, DIMENSION(3*3) :: inv
    REAL*4, DIMENSION(3) :: w, w_clip
    REAL*4, DIMENSION(3) :: soft_color
    REAL*4, DIMENSION(num_faces) :: soft_color_alpha
    REAL*4 :: sign, softmax_max, softmax_sum, zp, zp_norm, coef, color_k&
&   , soft_fragment, dis
    INTRINSIC INT
    INTRINSIC MOD
    INTRINSIC EXP
    LOGICAL :: result1
    DO bn=1,batch_size
!$OMP PARALLEL DO SHARED(image_size, batch_size, num_faces, texture_size&
!$OMP&, soft_colors_t, faces_t, textures_t, bn, texture_res, near, far, &
!$OMP&eps, sigma_val, gamma_val, dist_eps, threshold, double_side, &
!$OMP&texture_type), PRIVATE(pn, yi, xi, fn, k, d, pixel, inv, w, w_clip&
!$OMP&, soft_color, soft_color_alpha, sign, softmax_max, softmax_sum, zp&
!$OMP&, zp_norm, coef, color_k, soft_fragment, dis)
      DO pn=1,image_size*image_size
        yi = image_size - 1 - INT((pn-1)/image_size)
        xi = MOD(pn - 1, image_size)
        pixel(1) = (2.0*xi+1.0-image_size)/image_size
        pixel(2) = (2.0*yi+1.0-image_size)/image_size
        softmax_max = eps
        DO k=1,3
          soft_color(k) = 0.0
        END DO
        soft_color_alpha(1) = 1.0
        DO fn=1,num_faces
          d = (bn-1)*(num_faces*3*3) + (fn-1)*(3*3) + 1
          CALL FACE_INV(inv, faces_t, fn, bn)
          result1 = CHECK_BORDER(pixel, faces_t, threshold, fn, bn)
          IF (.NOT.result1) THEN
            CALL BARYCENTRIC_COORDINATE(w, pixel, inv)
            CALL BARYCENTRIC_CLIP(w_clip, w)
            zp = 1.0/(w_clip(1)/faces_t(d+2)+w_clip(2)/faces_t(d+5)+&
&             w_clip(3)/faces_t(d+8))
            IF (.NOT.(zp .LT. near .OR. zp .GT. far)) THEN
              result1 = CHECK_FACE_FRONTSIDE(faces_t, fn, bn)
              IF (result1 .OR. double_side) THEN
                zp_norm = (far-zp)/(far-near)
                IF (zp_norm .GT. softmax_max) softmax_max = zp_norm
              END IF
            END IF
          END IF
        END DO
        softmax_sum = EXP((2*eps-softmax_max)/gamma_val)
        DO k=1,3
          soft_color(k) = soft_colors_t((bn-1)*(4*image_size*image_size)&
&           +(k-1)*(image_size*image_size)+pn)*softmax_sum
        END DO
        DO fn=1,num_faces
          d = (bn-1)*(num_faces*3*3) + (fn-1)*(3*3) + 1
          IF (fn .GT. 1) soft_color_alpha(fn) = soft_color_alpha(fn-1)
          CALL FACE_INV(inv, faces_t, fn, bn)
          result1 = CHECK_BORDER(pixel, faces_t, threshold, fn, bn)
          IF (.NOT.result1) THEN
            CALL BARYCENTRIC_COORDINATE(w, pixel, inv)
            IF (w(1) .GT. 0 .AND. w(2) .GT. 0 .AND. w(3) .GT. 0 .AND. w(&
&               1) .LT. 1 .AND. w(2) .LT. 1 .AND. w(3) .LT. 1) THEN
              sign = 1.0
            ELSE
              sign = -1.0
            END IF
            dis = EUCLIDEAN_P2F_DISTANCE(faces_t, pixel, fn, bn)
            IF (.NOT.(sign .LT. 0.0 .AND. dis .GE. threshold)) THEN
              soft_fragment = 1.0/(1.0+EXP(-(sign*dis/sigma_val)))
              IF (fn .GT. 1) THEN
                soft_color_alpha(fn) = soft_color_alpha(fn-1)*(1.0-&
&                 soft_fragment)
              ELSE
                soft_color_alpha(fn) = 1.0 - soft_fragment
              END IF
              CALL BARYCENTRIC_CLIP(w_clip, w)
              zp = 1.0/(w_clip(1)/faces_t(d+2)+w_clip(2)/faces_t(d+5)+&
&               w_clip(3)/faces_t(d+8))
              IF (.NOT.(zp .LT. near .OR. zp .GT. far)) THEN
                result1 = CHECK_FACE_FRONTSIDE(faces_t, fn, bn)
                IF (result1 .OR. double_side) THEN
                  zp_norm = (far-zp)/(far-near)
                  coef = EXP((zp_norm-softmax_max)/gamma_val)*&
&                   soft_fragment
                  softmax_sum = softmax_sum + coef
                  DO k=1,3
                    color_k = FORWARD_SAMPLE_TEXTURE(textures_t, w_clip&
&                     , texture_res, k, texture_type, fn, bn)
                    soft_color(k) = soft_color(k) + coef*color_k
                  END DO
                END IF
              END IF
            END IF
          END IF
        END DO
        soft_colors_t((bn-1)*(4*image_size*image_size)+(4-1)*(image_size&
&       *image_size)+pn) = 1.0 - soft_color_alpha(num_faces)
        DO k=1,3
          soft_colors_t((bn-1)*(4*image_size*image_size)+(k-1)*(&
&         image_size*image_size)+pn) = soft_color(k)/softmax_sum
        END DO
      END DO
    END DO
  END SUBROUTINE TAPENADE_RENDER_MAIN

END MODULE TAPENADE_RENDER_DIFF

